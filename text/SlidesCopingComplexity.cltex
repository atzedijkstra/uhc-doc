%%[beamerTheme
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Theme used by beamer
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\usetheme{Singapore}
\usetheme[secheader]{Boadilla}
%\useoutertheme{infolines}
%%]

%%[config
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Config flags
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% let draft = True

%%]

%%[preamble
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Preamble
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\newcommand{\latex}{\LaTeX\xspace}
\newcommand{\latex}{LaTeX}
\newcommand{\lhstex}{Lhs2TeX}

%\barhs
%\setlength{\coderulewidth}{1.5pt}

\newcommand{\CITE}[1]{\footnote{\citetitle{#1}, \citeyear{#1}}}
\newcommand{\CITEU}[1]{\footnote{\citeurl{#1}}}

\newcommand{\Red}[1]{{\color{red}#1}}
\newcommand{\Itl}[1]{\textit{#1}}
\newcommand{\Emph}[1]{\Red{\Itl{#1}}}

%format (RED(x))	= "\Red{" x "}"
%format BLGRAY 	= "\color{lightgray}"

%format Ty_		= "\tau"
%format Env_	= "\Gamma"
%format PEnv_	= "{\cal{P}}"
%format Exp_	= "e"
%format Subst_	= "\theta"
%format subst_	= Subst_
%format Pred_	= "\pi"
%format pred_	= Pred_

%format tvara	= "\alpha"
%format tvarb	= "\beta"
%format tvar	= tvara
%format ty		= Ty_
%format tya		= Ty_ "_a"
%format Ty		= Ty_
%format pty		= "\sigma"
%format PTy		= pty
%format qty		= "\rho"
%format QTy		= qty
%format env		= Env_
%format Env		= Env_
%format penv	= PEnv_
%format PEnv	= PEnv_
%format exp		= "e"
%format Exp		= Exp_
%format subst	= Subst_
%format Subst	= Subst_
%format pred	= Pred_
%format Pred	= Pred_

%format oplus	= "\oplus"
%format otimes	= "\otimes"
%format otimesi(i)	= otimes "_{" i "}"
%format `subseteq`	= "\subseteq"

%format emptyset= "\emptyset"

%format TyInt	= "Int"

%format :=-		= "\mid"
%format ::-		= "\vDash"

%%]

%%[intro
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Intro
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \frametitle{\Emph{UHC}: Coping with Compiler {Complexity}}
  
  %\begin{itemize}
  %  \item 
    \Emph{UHC}: Utrecht Haskell Compiler
    \begin{itemize}
      \item Haskell2010 implementation
      \item Primarily intended for play \& experimentation: higher ranked types, partial type signatures, generic deriving, local instances, java(script) backend, ...
      \item Inspiration for tooling
    \end{itemize}
    
  %\end{itemize}

\end{frame}



\begin{frame}
  \frametitle{{UHC}: Coping with Compiler \Emph{Complexity}}

  %\begin{itemize}
  %  \item
    \Emph{Complexity}: dimensions of complexity
    \begin{itemize}
      \item From specification to implementation
      \item From deterministic to non-deterministic
      \item From few to many (combined) language features
      \item From small to large compiler input
    \end{itemize}
    
  %  \item
    \Emph{Approach}: keep specifications as simple as possible
    \begin{itemize}
      \item Compositionality as the holy grail
      \item DSL (Domain Specific Language)
      \item Generate (e.g. boilerplate code)
      \item Consistency between specifications
    \end{itemize}
    
  %\end{itemize}

\end{frame}



\begin{frame}
  \frametitle{{UHC}: Coping with Compiler {Complexity}}

  %\begin{itemize}
  %  \item
    \Emph{Assumptions}
    \begin{itemize}
      \item Basic Haskell
      \item Type systems (Hindley-Milner in particular)
    \end{itemize}
    
  %  \item
    \Emph{Take home}
    \begin{itemize}
      \item The 'art' of putting theory into practice (by implementing)
      \item Taking the 'art' out of this by using DSLs, tooling, engineering, ...
    \end{itemize}
  %\end{itemize}

\end{frame}


%if draft

\begin{frame}
  \frametitle{From specification to implementation}
  Outline

  \begin{itemize}
    \item Type system
    \item Impl adds computational direction: from rel to fun
    \item Specify as function
    \item Specify as AG
    \item Specify as |Ruler|, DSL, as beefed up AG
    \item Embed AG (Viera)
    \item Issue: repr subst
    \item Issue: free vars, leading to
    \item Optimize via incrementality (Bransen)
    \item Reasoning, CHR as DSL
  \end{itemize}
  
  Theme: use DSLs to cope with complexity

\end{frame}


\begin{frame}
  \frametitle{From few to many (combined) language features}
  UHC language feature ordering

  \begin{itemize}
    \item HM
    \item Higher ranked
    \item Type classes (local instances)
    \item Code gen
    \item ...
    \item Module system
    \item Libraries
    \item Haskell (report) corner cases
    \item Haskell2010
  \end{itemize}
  
  Theme: distinguish aspects/features

\end{frame}

%endif % draft


\begin{frame}
  \frametitle{Today's plan}
  
  \begin{itemize}
  \item Story thread: write a smallish UHC
  %\item Solutions tried for UHC, lessons learned, unexplored topics
  \pause
  \item Story `algorithm': While time left interleave
    \begin{itemize}
      \item Write or design a compiler fragment
      \item Observe/reflect upon problematic issues and solutions
      \item Explore routes taken by UHC
    \end{itemize}
  \end{itemize}

\end{frame}


%if draft

\section*{Contents}

\begin{frame}
  \tableofcontents
  
\end{frame}

%endif % draft


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Example
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Running example}

\begin{frame}
  \frametitle{Demo language}

\begin{itemize}
\item Basic functional language
%%[[wrap=safecode
   exp     ::=     i                       ^^ -- base: int
           |       n                       ^^ -- name reference
           |       exp ^^ exp              ^^ -- application
           |       \n.exp                  ^^ -- abstraction
           |       let n = exp in exp      ^^ -- let binding
%%]]

\item With Hindley-Milner type system
%%[[wrap=safecode
   ty      ::=     Int | ty -> ty | tvar
   pty     ::=     ty | forall tvar . pty
%%]]
\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Demo language}

\begin{itemize}
\item Language example
%%[[wrap=safecode
let id = \x.x in
let id2 = id id id id in
id id2 (id 5)
%%]]

\item Desired output and results
  \begin{itemize}
  \item Some analysis for some semantics: type
  \item Some error reporting: name errors, type errors
  \item Some code generation using analysis results: pretty printing
  \end{itemize}

\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Demo language}

\begin{itemize}
\item Compiler output

%%[[wrap=verbatimsmall
-- PP
let id : forall a. a -> (a)
       = \x.x in
let id2 : forall a. a -> (a)
        = id (id) (id) (id) in
id (id2) (id (5))
-- Ty
Int
%%]]
\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Demo language}

\begin{itemize}
\item Language example with a name error
%%[[wrap=safecode
let id = \x.y in
f 4
%%]]

\item Compiler output

%%[[wrap=verbatimsmall
-- PP
let id : forall a. a -> (ERR)
       = \x.y{- Not introduced: y -} in
f{- Not introduced: f -} (4)
-- Errors
Not introduced: y
Not introduced: f
%%]]
\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Demo language}

\begin{itemize}
\item Language example with typing error (Y fixpoint combinator)
%%[[wrap=safecode
\w . (\x.w(x x)) (\x.w(x x))
%%]]

\item Compiler output

%%[[wrap=verbatimsmall
-- PP
\w.\x.w (x (x){- Occurs: v2
                         v2 -> (v5) -}
        ) (\x.w (x (x){- Occurs: v8
                                 v8 -> (v11) -}
                )
          )
-- Errors
Occurs: v2
        v2 -> (v5)
Occurs: v8
        v8 -> (v11)
%%]]
\end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type system
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Type system specification}

\begin{frame}
  \frametitle{Writing a compiler for the demo language}
  
  What needs to be done?
  \begin{itemize}
  \item Specify the semantics (here: only type, not operational)
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Type semantics, declarative}

  Hindley-Milner type system (HM), declarative specification for type system
  {\small
  \rulerCmdUse{Lam.D.exp.onslide}
  }
  
  + generalization, instantiation ...

\end{frame}


\begin{frame}
  \frametitle{Type semantics, declarative}

  Generalization, instantiation
  {\small
  \rulerCmdUse{Lam.D.exp.gen}
  }
  
  \pause
  Can we directly implement this?
  \begin{itemize}
  \item When to apply rules?
  \item How to solve equations implied implicitly by multiple occurrences of meta variables (like |tya|)?
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Type semantics, syntax directed}

  For HM this is well known\footnote{\url{https://en.wikipedia.org/wiki/Hindley-Milner_type_system}}
  {\small
  \rulerCmdUse{Lam.SD.exp.onslide.sd}
  }
  
  Add and allow for computational direction
  \begin{itemize}
  \item When to apply rules? Make it syntax directed
  \item How to solve equations? Algorithm W (for example), unification, type variables \& substitution
  \end{itemize}
  
  %But...
  %\pause
  For an implementation design, algorithm, and engineering decisions have to be made
  
  %Observation: 
  

\end{frame}


\begin{frame}
  \frametitle{Type semantics, algorithmic}
  
  Algorithm W

  {\small
  \rulerCmdUse{Lam.A.exp.onslide}
  }

  Algorithmic |==| computable
  
  Ready to implement...
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Implementation: Haskell
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementation: Haskell}

%{

%%[[implPreamble
%format Ty		= "Ty"
%format ty		= "ty"
%format Env		= "Env"
%format env		= "env"
%format Exp		= "Exp"
%format Subst	= "Subst"
%format subst	= "subst"

%format TyInt	= "TyInt"

%format $->		= $ "_{" Subst_ "}"
%%]]

\begin{frame}
  \frametitle{Implementation}

  Haskell implementation of Algorithm W

%%[[wrap=safecode
algoW ::  Env   -> (  Subst, Int)  ->  Exp   -> (  Ty, (   Subst, Int), Err)
          Env_  ;     Subst_       :-  exp   :     Ty_ ~>  Subst_
%%]]

  \begin{center}
  \begin{tabular}{lll}
  \textbf{Type} &  &  \\ \hline
  |Env| & |Env_| & scoped environment, mapping from identifiers to types \\
  |Exp| & | Exp_| & term AST \\
  |Ty| & | Ty_| & types \\
  |Int| & & unique number generation, for fresh type variables \\
  |Subst| & | Subst_| & substitution, mapping type variables to types \\
  |Err| & & errors \\
  \end{tabular}
  \end{center}
  
  Syntax directed rules now allow pattern match on |Exp| to deterministically choose the right rule

\end{frame}


\begin{frame}
  \frametitle{Implementation, purely functional}

{\small
%%[[wrap=safecode
algoW :: Env -> (Subst, Int) -> Exp -> (Ty, (Subst, Int), Err)
algoW env st (Exp_App f a) =
    (s4 $-> v, (s4, uniq st3), ef ++ ea ++ eu)
  where 
    (tf,  st1, ef)  = algoW env st   f                  ^^ -- recurse for function
    (ta,  st2, ea)  = algoW env st1  a                  ^^ -- recurse for argument
    (v,   st3)      = fresh  st2                        ^^ -- new fresh type var
    s3              = subst  st3                        ^^ -- get current subst
    (su,  eu)       = unify  (s3 $-> tf)                ^^ -- apply subst, unify
                             (TyArr ta v)
    s4              = su $-> s3
    
    BLGRAY -- helper functions
    BLGRAY fresh (s,u) = (mkTyVar u, (s,u+1))
    BLGRAY subst = fst
    BLGRAY uniq = snd
%%]]
}

\end{frame}


\begin{frame}
  \frametitle{Implementation, purely functional}

Utility types (for reference)
{\small
%%[[wrap=safecode
data TyVar  = TV Int ...
data Ty     = TyInt | TyVar TyVar | TyArr Ty Ty | ...
data Exp    = Exp_App  Exp Exp | ...
type Env    = [(String,Ty)]
type Subst  = [(TyVar,Ty)]
class Substitutable x where {($->) :: Subst -> x -> x}
%%]]
}

\end{frame}


\begin{frame}
  \frametitle{Moments of reflection}
  
  What have we done so far?

  \begin{itemize}
    \item Started with concise declarative specification, which
    \begin{itemize}
      \item Via algorithmic version
      \item Led to functional implementation
      \item For which Haskell itself is already a good tool
    \end{itemize}
    \item But...
    \begin{itemize}
      \item Many low level details crept in while still many other details are left out
      \item An actual implementation must do more than just specify semantics: parser, scanner, ...
      \item Implementation for our example: approx 300 LOC (without comment)
    \end{itemize}
    
    \item And...
    \begin{itemize}
      \item We are not done yet...
      \item Pretty printing (as kind of code generation)
      % \item Error gathering
    \end{itemize}
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Moments of reflection}

  Can we \Emph{scale up}?
  
  \begin{itemize}
    \item The things/aspects |a1, a2, ...| we want to specify/compute per language construct?
    \item The number of language features/constructs |f1, f2, ...|?
  \end{itemize}
  
  \pause
  The \Emph{ideal} would be to be able to specify independently

  \begin{itemize}
    \item Aspects |a1| and |a2| and then combine them with some operator |oplus| into |a1 oplus a2|
    \item Language features |f1| and |f2| and then combine them with some operator |otimes| into |f1 otimes f2|
  \end{itemize}
  
  The \Emph{reality} is that aspects, features, and their combination usually must be 'aware' of each other to some degree.
  
  %% \pause
  %% \begin{itemize}
  %%   \item Why? How is this mitigated in UHC?
  %%   \item First, we look at combining aspects
  %% \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Implementation, pretty printing}
  
  Pretty printing: extra aspect for existing language constructs
  
  \begin{itemize}
    \item The ideal would be to define pretty printing independently of algoW:

%%[[wrap=safecode
pp :: Exp -> Doc
pp (Exp_App f a    )  =  pp f >|< pp a
pp (Exp_Let n e b  )  =  "let"  >|< pp n >|< "=" >|< pp e >|<
                         "in"   >|< pp b

data Doc = ...                      ^^ -- pretty print document
(>|<) :: Doc -> Doc -> Doc          ^^ -- concatenate horizontally
%%]]

  \item This works well if |pp| does not use info encapsulated in |algoW|
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Implementation, pretty printing}
  
  For independent aspects, this
  leads to nanopasses\CITE{Keep:2013:NFC:2520988}\CITE{laemmel03boilerplate}
  in compiler: small, maintainable, isolates solution for single (independent) problem
  
  \begin{itemize}
  \item Used in UHC for (e.g.) transformations of intermediate representations
  \item Can be inefficient, boilerplate overhead
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Implementation, pretty printing}
  
  The reality (complexity) here is that |pp| and |algoW| are dependent:
  pretty printing uses the inferred type (|te|) and error messages (|eu|) of |algoW|

%%[[wrap=safecode
pp :: Exp -> Doc
pp (Exp_App f a    )  =  pp f >|< pp a (RED( >|< pp eu))
pp (Exp_Let n e b  )  =  "let"  >|< pp n  (RED( >|< ":" >|< pp te >|<))
                                          >|< "=" >|< pp  e >|<
                         "in"   >|< pp b
%%]]

  Aspects type and pretty printing are not independent!

  In general, more complex analyses are dependent.

\end{frame}


\begin{frame}
  \frametitle{Implementation}

  Solution 1: refactor in the 'wrong' direction by adding |pp| to |algoW|:

{\small
%%[[wrap=safecode
algoW :: Env -> (Subst, Int) -> Exp -> (Ty, (Subst, Int), Err(RED(, Doc)))
algoW env st (Exp_App f a) =
    (s4 $-> v, (s4, uniq st3), ef ++ ea ++ eu(RED(, pf >|< pa >|< pp eu)))
  where 
    (tf,  st1, ef(RED(, pf)))  = algoW env st   f    
    (ta,  st2, ea(RED(, pa)))  = algoW env st1  a    
    (su,  eu)                  = unify  (s3 $-> tf) (TyArr ta v)
    ...
%%]]
}

  \begin{itemize}
  \item Adding an aspect implies a manual overhaul of boilerplate code
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Solution 2 (taken by UHC): DSL for computations over ASTs

  \begin{itemize}
  \item Each individual computation expressed as attribute
  \item Specification for each attribute can be separately described, combined later
  \item A compiler (UUAGC) glues separate specifications, generating functional program, including boilerplate
  \end{itemize}

  Allows thinking in terms of attributes associated with parent and children in AST,
  defining data flow fragments
  
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Implementation: AG
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementation: Attribute Grammar (AG)}


\begin{frame}
  \frametitle{Attribute grammars}
  
  %Way of thinking and programming now can be different
   
  \begin{itemize}
  \item All computation is defined in terms of attributes associated with parent and children
  \item Attributes are defined in terms of other attributes, thus specifying small dataflow fragments for parent and children
  \end{itemize}
  
  \begin{center}
  \agpictureAtY{4}{2}{flops2016-keynote/lam1env}
  \end{center}

  \begin{itemize}
  \item Inherited attributes 'travel' downwards (from root to leaves), synthesized upwards
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Environment
  
  \begin{center}
  \agpictureScaled{0.5}{flops2016-keynote/lam1env}
  \end{center}

%%[[wrap=safecode
DATA Exp                                    ^^ -- AST
  | App     f     : Exp
            a     : Exp

ATTR Exp [ env: Env | | ]                   ^^ -- inherited, from root to leaves

SEM Exp
  | App     f   .   env     =   @lhs.env    ^^ -- copied downwards
            a   .   env     =   @lhs.env
%%]]

Boilerplate copying (for |env|) usually omitted and generated automatically

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Unique number generation
  
  \begin{center}
  \agpictureAtY{8}{4}{flops2016-keynote/lam1uniq}
  \end{center}

%%[[wrap=safecode
ATTR Exp [ | uniq: Int | ]                   ^^ -- synthesized + inherited = state

SEM Exp
  | App     loc     .   v       =   mkTyVar @lhs.uniq
            f       .   uniq    =   @lhs.uniq + 1
%%]]

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Substitution
  
  \begin{center}
  \agpictureAtY{10}{5}{flops2016-keynote/lam1subst}
  \end{center}

%%[[wrap=safecode
ATTR Exp [ | subst: Subst | ]
%%]]

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Substitution, type, unification
  
  \begin{center}
  \agpictureAtY{12}{7}{flops2016-keynote/lam1ty}
  \end{center}

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  \begin{center}
  \agpictureScaledAtY{11}{6}{0.5}{flops2016-keynote/lam1ty}
  \end{center}

%%[[wrap=safecode
ATTR Exp [ | | ty: Ty ]     ^^ -- synthesized

SEM Exp
  | App  (loc.su,loc.eu)   =  unify  (@a.subst $-> @f.ty)
                                     (TyArr @a.ty @v)
         loc  .  s4        =  @su $-> @a.subst
         lhs  .  ty        =  @s4 $-> @v
              .  subst     =  @s4
%%]]

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Error collecting
  
  \begin{center}
  \agpictureAtY{8}{4}{flops2016-keynote/lam1err}
  \end{center}

%%[[wrap=safecode
ATTR Exp [ | | err : Err ]

SEM Exp
  | App				lhs	.	err		=	@eu ++ @f.err ++ @a.err
%%]]

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Similarly: pretty printing
  
  \begin{center}
  \agpictureAtY{7}{3}{flops2016-keynote/lam1ppApp}
  \agpicture{flops2016-keynote/lam1ppLam}
  \end{center}

%%[[wrap=safecode
ATTR Exp [ | | pp : Doc ]

SEM Exp
  | App				lhs	.	pp		=	@f.pp >|< @a.pp >|< ppErr @eu
  | Lam				lhs	.	pp		=	"\\" >|< @n >|< "." >|< @exp.pp
%%]]

(Ignoring layout details)

\end{frame}


\begin{frame}
  \frametitle{Moments of reflection}
  
  What have we done so far?

  \begin{itemize}
    \item Started with concise declarative specification, which
    \begin{itemize}
      \item Via algorithmic version
      \item Led to Attribute Grammar implementation
      \item Where all aspects can be described independently even though there are dependencies
      \item Generates Haskell using UUAGC (UU AG compiler)
      \item Combines separate specifications, generates boilerplate code
    \end{itemize}
    \item This works very well!
    \begin{itemize}
      \item In UHC, almost all functionality involving trees is expressed using AGs
      \item Integrates with Haskell ecosystem
    \end{itemize}
  \end{itemize}


\end{frame}


\begin{frame}
  \frametitle{Moments of reflection}
  
  Example, statistics for UHC: use of UUAGC (and other languages)
  
  \begin{center}
  \FigScaledPDF{0.6}{codesize}
  \end{center}

  %\pause
  %But...

\end{frame}


\begin{frame}
  \frametitle{Moments of reflection}
  
  Drawbacks

  \begin{itemize}
    \item We still have to know about dependencies
    \begin{itemize}
      \item Luckily, UUAGC gives feedback about dependency related errors
    \end{itemize}
    \item UUAGC is a preprocessor: checks for AG specifics, but not Haskell specifics of embedded Haskell code
    \begin{itemize}
      \item We get Haskell errors too late, only when generated code is compiled
    \end{itemize}
    \item One has to learn a separate language
    \begin{itemize}
      \item And the additional tooling etc.
    \end{itemize}
    \item Implementation done manually, what guarantees do we have about consistency with type rules?
    \begin{itemize}
      \item Maintaining two copies of the same is a nightmare
    \end{itemize}    
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Moments of reflection}

  Alternative approach: plumbing via underlying implementation language

\begin{itemize}
\item A monadic interface for Algorithm W
%%[[wrap=safecode
algoW
      ::  (  MonadReader Env m                  ^^ -- scoped name mapping
          ,  MonadState (Subst, Int) m          ^^ -- global state
          ,  MonadError Err m                   ^^ -- error/exception
          (RED(, MonadWriter Doc m))            ^^ -- \Red{pretty printing}
          ) => Exp -> m Ty
%%]]
\item Or, more recently: extensible effects, data types a la carte
\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Moments of reflection}

  Common mechanisms (with their drawbacks)
  
  \begin{itemize}
    \item Layers are combined, requires scheduling overhead
    \begin{itemize}
      \item Running overhead
      \item Crossing boundaries overhead (i.e. dependencies between different aspects)
      \item Layers/aspects indexed by types
    \end{itemize}
    \item Each aspect is a separate layer of functionality indexed by a type
    \begin{itemize}
      \item Type must be unique amongst aspects
    \end{itemize}
  \end{itemize}
  
  Extensible building of languages can also be directly modelled in host language Haskell...
  
  But...
  \pause
  in both cases comes with runtime overhead and need to be aware of (type level) glueing


\end{frame}


\begin{frame}
  \frametitle{Language variants: |AspectAG|}
  
  Type safe embedding in Haskell of parsers, syntax macros, AST definition, Attribute Grammars\CITE{Viera:2013uo} as knittable fragments
    
  \begin{center}
  \FigScaledPDF{0.6}{talk-ag-fly-1st-class-comparison1}
  \end{center}
  
\end{frame}



\begin{frame}
  \frametitle{Language variants: |AspectAG|}
  
  Example: Oberon compiler (LDTA challenge\CITE{Anonymous:t9Gd69Tm}) implementation demonstrates dealing with expression problem
  
  \begin{center}
  \FigScaledPDF{0.4}{talk-ag-fly-1st-class-comparison2}
  \end{center}
  
  Elegant though inefficient: heavy use of type level programming, template haskell, resulting code difficult to optimize
  
  
  
\end{frame}



\begin{frame}
  \frametitle{Moments of reflection}

  Alternative approach: visitor pattern from the object-oriented world
  
  \begin{itemize}
    \item Must know about dependencies between results from visits
    \item (Side effects)
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Moments of reflection}

  Core idea of Attribute Grammars, UUAGC in particular
  
  \begin{itemize}
    \item Restricted form of functional programming (catamorphisms)
    \item Declaratively specify dependent computations (via attributes)
    \item Is a preprocessor/compiler,
    \item allows dependency analysis and tailormade codegen, in particular avoids overhead of monad (and similar) approaches
  \end{itemize}
  
  UUAGC computes how the logistics/scheduling can be done

  \begin{itemize}
    \item No need to worry about this as a programmer
    \item Facilitates easy modification (which we wanted for experimentation)
  \end{itemize}

\end{frame}


%{
%%@SlidesCopingComplexity.implPreamble

\begin{frame}
  \frametitle{Implementation: multiple visits/passes}
  
  Example: need for visits/passes
  
  \begin{itemize}
    \item Small change in running example: pretty print of lambda expression should include inferred type
    \item Input
%%[[wrap=safecode
((\x.x) 5)
%%]]
    \item Should pretty print to
%%[[wrap=verbatim
(\x:Int.x) (5)
%%]]
    \item We know the type: type variable + substitution
  \end{itemize}

  Substitution |subst| only known after type inference of whole program is done: pass final |subst| (as |substFin|) from |Root| downwards as 2nd pass/visit

\end{frame}


\begin{frame}
  \frametitle{Implementation: multiple visits/passes}
  
  \begin{center}
  \agpictureScaled{0.7}{flops2016-keynote/lam1finsubstRoot}
  \agpictureScaledAtY{8}{3}{0.7}{flops2016-keynote/lam1finsubstLam}
  \end{center}

%%[[wrap=safecode
ATTR Exp [ substFin: Subst | | ]

SEM Root
  | Root            exp .   substFin    =   @exp.subst

SEM Exp
  | Lam             lhs .   pp          =   "\\"  >|< @n
                                                  >|< ":" >|< pp (@lhs.substFin $-> @v)
                                                  >|< "." >|< @exp.pp
%%]]  
    
\end{frame}


\begin{frame}
  \frametitle{Implementation: multiple visits/passes}
  
  UUAGC generates 2 visits (don't try to understand it all...)

{\tiny
%%[[wrap=safecode
type T_Exp = Env -> Subst -> Int -> (Subst,Ty,Int,T_Exp_1)                                      ^^ -- 1st visit (type)
type T_Exp_1 = Subst -> ( Err,PP_Doc)                                                           ^^ -- 2nd visit (type)
sem_Exp_App :: T_Exp -> T_Exp -> T_Exp                                                          ^^ -- 1st visit
sem_Exp_App f_ a_ = \ _lhsIenv _lhsIsubst _lhsIuniq ->
  let     BLGRAY (_fOuniq,_uniq1) = rulerMk1Uniq _lhsIuniq
  BLGRAY  BLGRAY ( _fIsubst,_fIty,_fIuniq,f_1) = f_ _lhsIenv _lhsIsubst _fOuniq
  BLGRAY  BLGRAY _tvar_ = mkTyVar _uniq1
  BLGRAY  BLGRAY ( _aIsubst,_aIty,_aIuniq,a_1) = a_ _lhsIenv _fIsubst _fIuniq
  BLGRAY  BLGRAY (_subst_u_,_errUnify) = unify (_aIsubst $-> _fIty) (TyArr _aIty _tvar_)    ^^
          sem_Exp_1 = \ _lhsIsubstFin ->                                                    ^^ -- 2nd visit
  BLGRAY  BLGRAY   BLGRAY let  BLGRAY ( _aIerr,_aIpp) = a_1 _lhsIsubstFin
  BLGRAY  BLGRAY   BLGRAY      BLGRAY ( _fIerr,_fIpp) = f_1 _lhsIsubstFin
  BLGRAY  BLGRAY   BLGRAY in   BLGRAY ( _errUnify ++ _fIerr ++ _aIerr
  BLGRAY  BLGRAY   BLGRAY      BLGRAY , _fIpp >#< ppParens _aIpp >|< ppErr _errUnify )
  in      BLGRAY (  BLGRAY _subst_u_ $-> _aIsubst, _subst_u_ $-> _tvar_
  BLGRAY  BLGRAY ,  BLGRAY _aIuniq
          BLGRAY ,  sem_Exp_1 )
%%]]  
}

  %Personal opinion: happy not to have to write this manually...

\end{frame}


%}
  

\begin{frame}
  \frametitle{Implementation: multiple visits/passes}
  
  Example, statistics for UHC
  \begin{itemize}
    \item For analysis of expression terms: 8 visits
    \begin{center}
    \begin{tabular}{l||p{.5\linewidth}lll}
       &  & \multicolumn{3}{l}{\textbf{nr of}} \\ 
       & \textbf{deals with} & \textbf{inh} & \textbf{syn} & \textbf{inh+syn} \\ \hline
        0 & source text info & & & 1 \\
        1 & unique (fresh) identifier generation & & 1 & 1 \\
        2 & type/kind env & 3 & & 1 \\
        3 & kind/polarity inference/checking & 6 & & 3 \\
        4 & class env, final type/kind env, datatype gathering & 4 & & 1 \\
        5 & new class/instance gathering & 1 & 4 & \\
        6 & CHR env, value env, type inference & 8 & 5 & 1 \\
        7 & final value env, error gathering, ...  & 9 & 31 & 1 \\ \hline
          &  & 31 & 41 & 9 \\
    \end{tabular}
    \end{center}
  \end{itemize}
  
\end{frame}

  

\begin{frame}
  \frametitle{Moments of reflection}

  What \Emph{guarantees} easier change?
  
  \begin{itemize}
    \item Embed DSLs, allowing better error reporting
    \item One DSL for both type rules and implementation of them
  \end{itemize}
  
  \pause
  The \Emph{ideal} would be to be able to specify declaratively

  \begin{itemize}
    \item The type system, with 'magic' figuring out a corresponding implementation
    \item An implementation using various DSLs inside one host language
  \end{itemize}
  
  The \Emph{reality} is that type systems soon are too complex,
  'magic' does not exist, embedding DSLs is still ongoing research,
  and an implementation involves usually |>1| host languages
  
  \pause
  %% \begin{itemize}
  %%   \item Why? How is this mitigated in UHC?
  %%   \item First, we look at consistency between type rules and implementation
  %% \end{itemize}
  
  In UHC: consistency between type rules and implementation via |Ruler| system
  

\end{frame}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Implementation: |Ruler|
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementation: |Ruler|}


\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  Specification of type semantics often done in \latex
  
  \[
  \rulerCmdUse{Lamnochng.A.exp.core.app}
  \]

  But ...
  \\ Is \latex\ (+ \lhstex) a good specification language for type rules?

\end{frame}


\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  \latex\ + \lhstex:

%%[[latexForRulerRuleAppA
{\tiny
%%[[wrap=verbatim
\rulerRule{app}{A}
{ | tvar | \;\mbox{fresh} | |
\\| subst ; env :- f : ty | _{ | f |} | ~> subst | _{ | f |} | |
\\| subst | _{ | a |} | ty | _{ | f |} | === ty | _{ | a |} | -> tvar ~> subst | _{ | u |} | |
\\| subst | _{ | f |} | ; env :- a : ty | _{ | a |} | ~> subst | _{ | a |} | |
 }
{ | subst ; env :- f ^^ a : subst | _{ | u |} | tvar ~> subst | _{ | u |} | subst | _{ | a |} | | }
%%]]
}
%%]]

Gives us pretty rendering in papers and (these) slides...

But...

  \begin{itemize}
    \item Mixup of specification \& rendering
    \item Check for identifier introduction?
    \item Judgement conforms to its required structure?
    \item Typing of type rules?
  \end{itemize}

And...

\end{frame}


\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  How can we keep type rules and their implementation consistent?
  
  \[
  \rulerCmdUse{Lamnochng.A.exp.core.app}
  \]

{\small
%%@Lam_A_ruler.2.exp.app wrap=safecode
}

\end{frame}


\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  In general, given a specification for some semantics, we (want to)
  
  \begin{enumerate}
    \item \label{semgenrender} Render it for \Emph{human reading} \& reasoning,
    \item \label{semgenreason} Feed it into \Emph{theorem proving} machinery for (automated/mechanized) reasoning,
    \item \label{semgenexec} Generate code for \Emph{actual execution} (of e.g. a checker)
  \end{enumerate}
  
  The \Emph{ideal} would be to obtain all 3 from a single description.
  
  The \Emph{reality} is that for a given tool we get (approx) 2 out of 3...
  
  \vspace{2ex} \pause
  For UHC, |Ruler| gives us \ref{semgenrender} \& \ref{semgenexec}:
  previous slide contains generated rendering and AG code

\end{frame}



\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  One specification from which everything else is generated
  
  Not a new idea:
  
  \begin{center}
  \begin{tabular}{l||p{.17\linewidth}p{.17\linewidth}p{.17\linewidth}p{.17\linewidth}}
                  & \multicolumn{4}{l}{ \textbf{Generates for, or implements}} \\
  \textbf{System} &  \textbf{\latex} &  \textbf{mechanized reasoning} &  \textbf{verified code} & \textbf{verifying code} \\ \hline
  Ott\CITE{sewell2010ott-jfp} & \checkmark & \checkmark & & \\
  Coq\CITEU{Anonymous:J735rZAA} & \checkmark & \checkmark & \checkmark (extraction) & \\
  |Ruler|\CITE{dijkstra06ruler} & \checkmark & & & \checkmark (AG checker) \\
  \end{tabular}
  \end{center}
  
  But...
  
\end{frame}



\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  Generating a checker for type rules (i.e. code which verifies) is rather difficult
  
  \begin{itemize}
    \item Why? How did we experiment with |Ruler| in UHC? What is |Ruler|?
    %\item First, we look at |Ruler|
  \end{itemize}
  
\end{frame}



\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  |Ruler|
  
  \begin{itemize}
    \item Specify rules
    \item Generate \latex\ and/or AG code
  \end{itemize}
  
  The \Emph{good news}

  \begin{itemize}
    \item Example in these slides is generated from a single |Ruler| specification (+ additional helper code)
  \end{itemize}
  
  %For example...

  
\end{frame}



%{
%format exp		= "exp"

\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  |Ruler| example

%%@HMDemoLam.schemeExp wrap=safecode

Specifies

  \begin{itemize}
    \item for the view |D| (declarative)
    \item the 'type' of judgements for |exp|,
    \item its parsing, and
    \item \latex\ rendering (here same as parsing spec)
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  |Ruler| example

%%@HMDemoLam.ruleAppViewD wrap=safecode

  Specifies a single rule instance |app| of scheme (type) |exp|

  %Generates...

\end{frame}


\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  Generates (already seen)

%%@SlidesCopingComplexity.latexForRulerRuleAppA

  which with a little help from \lhstex\ renders as (also already seen)

  {\small
  \rulerCmdUse{Lam.D.exp.onslideApp}
  }
  
\end{frame}


\begin{frame}
  \frametitle{Implementation: |Ruler|}
    
  The \Emph{bad news}

  \begin{itemize}
    \item |Ruler| can generate only when rules are algorithmic and syntax driven
    \item Which the declarative variant of our example is not, so
    \item Need to add additional info or override existing to arrive at a rule from which we can generate AG
  \end{itemize}

  |Ruler| provides mechanisms for additional or replacement specification to obtain

  \begin{center}
  \begin{tabular}{p{.4\linewidth}p{.4\linewidth}}
  {\small
  \rulerCmdUse{Lam.D.exp.core.app}
  }
  &
  {\small
  \rulerCmdUse{Lam.A.exp.core.app}
  }
  \\
  \end{tabular}
  \end{center}
  
  
\end{frame}


\begin{frame}
  \frametitle{Implementation: |Ruler|}
    
  %The \Emph{worse news}
  The \Emph{really bad news}
  \begin{itemize}
    \item Rules being algorithmic and syntax driven is not enough for many type systems
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  Why is it that rules being algorithmic and syntax driven is not enough for many type systems?
  \begin{itemize}
    \item Deterministic vs. non-deterministic!
  \end{itemize}
    
  When is non-determinism \Emph{present} and/or \Emph{required}?
  \begin{itemize}
    \item In Hindley-Milner type system example non-deterministism is present, but not required, because we can transform it to
    \item Algorithm W: deterministic, because rule choice is syntax driven, algorithmic because relationships have direction (are functions, computable)
  \end{itemize}
  
  \pause
  \begin{itemize}
    \item Counterexample: Haskell type class system cannot be dealt with in a syntax driven way
  \end{itemize}

  Let's look at its rules and see why...
    

\end{frame}


%}

%}



\begin{frame}
  \frametitle{Example: Haskell type class system}
  
Haskell type class system

\begin{itemize}
\item Haskell example
%%[[wrap=safecode
   class Eq a where
     (==) :: a -> a -> Bool
   instance Eq Int where ...
   instance Eq a => Eq [a] where ...
   
   f :: Eq a => a -> a -> Bool          ^^ -- specified or inferred
   f x y = x == y                       ^^ -- just a (nonsensical) example
%%]]

\item Extension of running example with qualified types
%%[[wrap=safecode
   ty      ::=     Int | ty -> ty | tvar        ^^
   qty     ::=     ty | pred => qty             ^^ -- qualified
   pred    ::=     Eq ty | ...
   pty     ::=     qty | forall tvar . pty
%%]]
\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Example: Haskell type class system}
  
  Extension of Hindley-Milner type system\CITE{jones94phd-qual-types}, declaratively
  {\small
  \rulerCmdUse{Lam.Q.exp.onslide}
  }
  
  \begin{itemize}
    \item |PEnv| : assumed (i.e. given, true, ...) type class predicates
    \begin{itemize}
      \item E.g. |Eq Int, Eq a => Eq [a]|
    \end{itemize}
    \item Almost independent extension of HM ...
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Example: Haskell type class system}
  
  Only need to tweak generalization
  
  {\small
  \rulerCmdUse{Lam.Q.exp.gen}
  }

\end{frame}


\begin{frame}
  \frametitle{Example: Haskell type class system}
  
  Additional rules for predicate introduction and elimination
  {\small
  \rulerCmdUse{Lam.Q.exp.pred}
  }
  
  Entailment |penv ::- pred|
  
  \pause
  \begin{itemize}
    \item Usual rules: transitivity, ...
    \item Rules derived from class/instance definitions
    \item Requires a small theorem prover
    \begin{itemize}
      \item E.g. to derive |Eq [Int]| from |Eq Int, Eq a => Eq [a]|
    \end{itemize}
  \end{itemize}

  \pause
  So, why is this a problem?
  

\end{frame}


\begin{frame}
  \frametitle{Example: Haskell type class system}
  
  Can we make the rules syntax directed and algorithmic?
  \begin{itemize}
    \item To some degree, but...
    \begin{itemize}
      \item Direction of |PEnv| is inherited: classes and instances are given
      \item Direction of |PEnv| is synthesized: during type inference occurrences of identifiers give rise to |pred|s
      \item Predicates |pred| may involve type variables for which we 'later' find substitutions
    \end{itemize}
    \item Theorem proving (context reduction) usually ends up being done in |let| expression, before generalization
    \begin{itemize}
      \item Constraint solving: gather constraints syntax directed, prove somewhere else
      \item Need results still at location where constraint arose
    \end{itemize}
  \end{itemize}
  
  \pause
  In general
  
  \begin{itemize}
    \item The more complex a type system, the less can be done syntax directed, the more must be done via constraint solving (possibly involving backtracking)
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Implementation: |Ruler|}
    
  %The \Emph{worse news}
  Back to the \Emph{really bad news}
  \begin{itemize}
    \item Rules being algorithmic and syntax driven is not enough for many type systems
  \end{itemize}
  
  Solutions:
  \pause
  \begin{itemize}
    \item Just a Prolog program!
    \begin{itemize}
      \item Can we really live with the resulting inefficiencies?
    \end{itemize}
    \item Paradigm mix: deterministic (syntax directed) AG-like and non-deterministic (logic programming, constraint solving, backtracking) Prolog-like programming
    \begin{itemize}
      \item Given a declarative set of (type) rules, can we figure out what can be done using which paradigm?
    \end{itemize}
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Implementation: multiple visits/passes}
    
  Exploration in context of UUAGC, inspired by UHC:

  Implementation mechanisms\CITE{middelkoop2012phd-ag-visit}
  for which a combi of AG and constraint solving solutions can be generated
  \begin{itemize}
    \item Explicit scheduling for attribute evaluation: sequence of visits/passes
    \begin{itemize}
      \item Each visit/pass a coroutine
    \end{itemize}
    \item Can be invoked syntax directed or uncoupled from syntax (as part of constraint solving)
    \item Can backtrack; can give partial results
  \end{itemize}
  
  \pause
  \begin{itemize}
    \item 
      Left unexplored: design of a |Ruler| successor which allows declarative and algorithmic part to be independently specified,
      thus avoiding 'pollution' of declarative part
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Moments of reflection: UUAGC, |Ruler|, (non)determinism}
  
  UUAGC
  
  \begin{itemize}
    \item Great for: 'tree-oriented' programming: syntax directed, deterministic
    \item Great for: independent specifications for attributes, combined later on
    \item Dependency analysis gives efficient (strict) visit based code
    \item Generates boilerplate code
    \item Manages \Emph{complexity} of aspects
  \end{itemize}
  
  Used a lot in UHC, and in other tools as well
  
  \begin{itemize}
    \item Still have to look at: combining language features (not just aspects per feature)
    %\item Still have to look at: embedding in Haskell to improve usability
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Moments of reflection: UUAGC, |Ruler|, (non)determinism}
  
  |Ruler|
  
  \begin{itemize}
    \item In addition to UUAGC: pretty (\latex) printing of type rules
    \item Inspired exploration of visits as target machine model for checkers using syntax directedness, constraint solving, and backtracking
  \end{itemize}
  
  But, as it is, |Ruler| not used anymore in UHC as it offers too little on top of UUAGC

  Management of \Emph{complexity} (of choice) of implementation mechanisms: still unresolved

\end{frame}


\begin{frame}
  \frametitle{Moments of reflection: UUAGC, |Ruler|, (non)determinism}
  
  Nondeterminism
  
  \begin{itemize}
    \item In declarative specification (of rules)
    \begin{itemize}
      \item Convert to algorithmic specification
      \item The (practical attainable) \Emph{ideal} would be to annotate (in |Ruler|) which mechanism (|`elem` {|syntax directedness, unification, constraint solving, ...|}|) should be used
    \end{itemize}
    \item In the language (for which we specify rules)
    \begin{itemize}
      \item Language specification may allow ambiguity
      \item In Haskell: higher ranked types, overlapping instances, (in UHC) local instances
      \item Language mechanisms for explicitly disambiguating: type signatures, functional dependencies, (in UHC) named instances
      \item The \Emph{ideal} programming language should offer for each implicit mechanism possibly leading to ambiguity an explicit mechanism for disambiguation
    \end{itemize}
  \end{itemize}
  

\end{frame}

  

\begin{frame}
  \frametitle{Moments of reflection: UUAGC, |Ruler|, (non)determinism}
  
  Presence of non-determinism ultimately leads to `choosing' mechanisms
  
  In UHC: local instances
  
%%@TopicCHRLocalInst.classEq  
  
\end{frame}


\begin{frame}
  \frametitle{Moments of reflection: UUAGC, |Ruler|, (non)determinism}
  
  In UHC
  
  \begin{itemize}
    \item Choosing via naming instances (by the UHC programmer)
    \item Delaying choice in the implementation by generating all possible solutions
    \begin{itemize}
      \item Uses DSL for rule based programming: Constraint Handling Rules (CHR)\CITE{Dijkstra:2007vm}
      \item Rules deal with scope explicitly
      \item Left unexplored: programmer specifiable strategies for choosing
      \item Limitation: CHR variant too limited to be able to deal with (e.g. functional dependencies, ...)
    \end{itemize}
  \end{itemize}
  
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Language variants: Shuffle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Language variants: Shuffle}


\begin{frame}
  \frametitle{Compositionality of language features}
  
  Language features versus implementation aspects  

  \begin{itemize}
    \item UUAGC takes care about compositionality of aspects (type system, pretty printing, ...) of language features
  \end{itemize}
  
  How does UHC deal with compositionality of language features?

\end{frame}



%{

%format pi      = p "_i"
%format pj      = p "_j"
%format pij     = p "_{i,j}"
%format si      = s "_i"
%format sj      = s "_j"
%format sk      = s "_k"
%format sij     = s "_{i,j}"
%format sijk    = s "_{i,j,k}"
%format s12     = s "_{1,2}"
%format fi      = f "_i"
%format fj      = f "_j"
%format fij     = f "_{i,j}"
%format <~>     = "\sim"


\begin{frame}
  \frametitle{Compositionality of language features}
  
  Desired compositionality:

  \begin{itemize}
    \item Informally: need not modify individual specifications when composing
    \begin{itemize}
      \item \Emph{ideal}: concatenate textually
      \item \Emph{reality}: concatenate textually + additional glue/override
    \end{itemize}
    \item More formally:
    \begin{itemize}
      \item Given (already theoretical/formally well defined) language features |fi| (|i `elem` {1,2}|),
      %% \item its (already figured out) individual and combined semantics/interpretation |i(f1), i(f2), i(f1 + f2)|,
      \item (textual) specifications |si| for |fi| for which we have already some notion |<~>| of correctness |si <~> fi|,
      \item feature combination '|+|' and textual specification concatenation '|++|',
      \item specific additional specification |s12| to make hold |(s1 ++ s2 ++ s12) <~> (f1 + f2)|,
      \item if |s12 = emptyset| then specifications |s1, s2| are compositional
    \end{itemize}
    \item What about compositionality for |f1 + f2|?
    \begin{itemize}
      \item Practical reformulation: given published papers |pi| for |fi|, what about |p1 + p2|?
    \end{itemize}
    %% \begin{itemize}
    %%   \item \Emph{ideal}: type system for such specifications
    %%   \item \Emph{reality}: no type system
    %% \end{itemize}
    %% \item More formally: textual specifications of semantics |s1| and |s2| for language features |f1| and |f2|
    %%  \emph{compose} when for all interpretations |i| and interpretation compositions |otimesi(i)|,
    %%  for the textual concatenation holds |i (s1 ++ s2) = i s1 ^ otimesi(i) ^ i s2|,
    %%  where |i s| is a \emph{correct} interpretation according to some unspecified notion of correctness |c f| of its corresponding language feature |f|,
    %%  for which we assume we have |c f|, |f `subseteq` {f1,f2}|
  \end{itemize}
  
\end{frame}



\begin{frame}
  \frametitle{Compositionality of language features}
  
  Not a new idea:

  \begin{center}
  \begin{tabular}{l||p{.30\linewidth}p{.30\linewidth}}
                  & \multicolumn{2}{l}{ \textbf{|i=|}} \\
  \textbf{System}  & \textbf{operational semantics} &  \textbf{verifying code} \\ \hline
  TinkerType\CITE{levin99tinkertype} & \checkmark & \checkmark (unchecked) \\
  PlanCompS\CITE{Churchill:2015ey}  & \checkmark & \checkmark \\
  |Shuffle|(UHC) & ? & ? \\
  \end{tabular}
  \end{center}
  
\end{frame}



\begin{frame}
  \frametitle{Compositionality of language features}
  
  Is \Emph{composition} of specifications (for language features) possible?
  
  \begin{itemize}
    \item Observation: usually |sij /= emptyset| for arbitrary |si,sj|
    \item For |n| features $> O(n^2)$ combinations, |sk| might require |sijk| specifics
    % \item Does |c f, f `subseteq` {f1,f2}| imply that their specifications |s1| and |s2| compose?
    % \item Compositional for arbitrary specifications |s1| and |s2| (of |f1| and |f2|)?
    % \item Is semantics specification associative, |(s1 ++ s2) ++ s3 = s1 ++ (s2 ++ s3)|, where both |i (s1 ++ s2)| and |i (s2 ++ s3)| are correct interpretations?
    % \item (If associative, is semantics specification commutative, for example |(s1 ++ s2) ++ s3 = s2 ++ (s1 ++ s3)|, where both |i (s1 ++ s2)| and |i (s1 ++ s3)| are correct interpretations?)
  \end{itemize}
  
  In context of UHC: \Emph{no}
  
  \begin{itemize}
    \item A language feature may rely on another language feature: Haskell type class system requires expressions and/or type system
    \begin{itemize}
      \item Ordering between language features, 'later' features have no meaning on their own
    \end{itemize}
    \item A language feature may have to override the specification of another feature when combined: Haskell type class system changes (e.g.) code generation
    \begin{itemize}
      \item Composing can potentially require (ad-hoc, implementation specific) changes on individual specifications of features
    \end{itemize}
  \end{itemize}
  
\end{frame}



\begin{frame}
  \frametitle{Compositionality of language features}
  
  Expression Problem\CITE{Wadler:AR2HUucS} 
  
  \begin{itemize}
    \item Feature: structure, data type, AST
    \item Aspect: computation, semantics
  \end{itemize}

  \begin{center}
  \def\FBox{\fbox{
	\begin{minipage}{3em}
		\hfill\vspace{1.5ex}
	\end{minipage}
	}}
  \begin{tabular}{rr||llll}
                    & ...    & \FBox{}    & \FBox{}      & \FBox{} \\ 
                    & pretty & \FBox{}    & \FBox{}      & \FBox{} \\ 
  aspect $\uparrow$ & typing & \FBox{}    & \FBox{}      & \FBox{} \\ \hline
                    &        & expression & type classes & ... \\ 
                    &        & \multicolumn{2}{l}{$\rightarrow$ feature} \\
  \end{tabular}
  \end{center}
  
  \begin{itemize}
    \item UUAGC compositionality: able to independently fill in the squares
    \item Square ordering
    \begin{itemize}
      \item Square assumes presence of other square
      \item Square overrides (part of) other square (difficult to do with UUAGC)
    \end{itemize}
  \end{itemize}
    
  %How does UHC deal with compositionality of language features?

\end{frame}



\begin{frame}
  \frametitle{Language variants: |Shuffle|}
  
  For UHC:

  \begin{itemize}
    \item Composing requires ad-hoc composition specific overriding
    \begin{itemize}
      \item Restrict to ordering of features building on top of each other
      \item Aspects as independent of features as possible
    \end{itemize}
    \item Features and aspects are relevant for all artefacts of a compiler
    \begin{itemize}
      \item AG files, Haskell files, C (runtime system), ...
      \item Only manipulation of file content, semantics agnostic
    \end{itemize}
  \end{itemize}

  Tool |Shuffle| selects and shuffles around text fragments annotated with aspect and variant (language feature)

\end{frame}



\begin{frame}
  \frametitle{Language variants: |Shuffle|}
  
  Example from UHC:
  
%%[[wrap=verbatim
 %%[(2 hmtyinfer || hmtyast).mkTyVar hs
 mkTyVar :: TyVarId -> Ty
 mkTyVar tv = Ty_Var tv
 %%]
%%]]

Haskell (hs) fragment to be included in the compiler for variant 2, when incorporating type AST (hmtyast) or type inference (hmtyinfer)

\end{frame}



\begin{frame}
  \frametitle{Language variants: |Shuffle|}
  
  Example from UHC:
  
%%[[wrap=verbatim
 %%[(3 hmtyinfer || hmtyast).mkTyVar -2.mkTyVar hs
 mkTyVar :: TyVarId -> Ty
 mkTyVar tv = Ty_Var tv TyVarCateg_Plain
 %%]
%%]]

Override a fragment for variant 3

\end{frame}


\begin{frame}
  \frametitle{Language variants: |Shuffle|}
  
  In UHC
  
  \begin{center}
  \begin{tabular}{r||ll}
     & \textbf{Plain Haskell} & \textbf{Experiments} \\ \hline
  1  & $\lambda$-calculus, type checking & \\
  2  & type inference &  \\
  3  & polymorphism &  \\
  4  &  & higher ranked types, existentials \\
  5  & data types &  \\
  6  & kind inference & kind signatures \\
  7  & records & tuples as records \\
  8  & code generation & whole program analysis \\
  9  & classes, type-synonyms & extensible records \\
  ..  & modules &  \\
  ..  & deriving &  \\
  ..  & prelude, I/O &  \\
  ..  & Haskell &  \\
  \end{tabular}
  \end{center}

\end{frame}


\begin{frame}
  \frametitle{Language variants: |Shuffle|, |Ruler|}
  
  \begin{center}
  \only<1>{\FigScaledPDF{0.4}{toolchain2d}}
  \only<2>{\FigScaledPDF{0.4}{toolchain2e}}
  \only<3>{\FigScaledPDF{0.4}{toolchain2f}}
  \end{center}

\end{frame}


\begin{frame}
  \frametitle{Language variants: |Shuffle|}
  
  |Shuffle| \Emph{good news}
  
  \begin{itemize}
    \item Can build compiler per variant
    \item Can turn on/off aspects (configuration management)
    \item Shuffle fragments can be referred to by name for text inclusion (literate programming)
    \item Helps with debugging
  \end{itemize}

  \pause
  |Shuffle| \Emph{bad news}

  \begin{itemize}
    \item Rather crude/simple 'textual only' tool
    \item Makes build system complex, adds another language to be learned
    \item Keeping all combinations working takes effort, not all combinations can work
  \end{itemize}

  % \pause
  % |Shuffle| \Emph{worse news}
  % 
  % \begin{itemize}
  %   \item Even limiting compositionality to some feature order does not 'work' ...
  % \end{itemize}
  % 
  % What can be done to mitigate this?
  
  

\end{frame}



\begin{frame}
  \frametitle{Moments of reflection: compositionality}
  
  Original approach/desire: use compositionality to simplify specification of UHC

  Does it work? Can it be done?
  
  \begin{itemize}
    \item Yes, when aspects/features are independent
  \end{itemize}
  
  When restricted to feature ordening in the presence of dependency between features
  
  \begin{itemize}
    \item Features become tightly coupled
    \item Subsequent feature may need redesign of implementation of previous feature
    \begin{itemize}
      \item Either must override a lot, or design for the last feature
      \item Making the first feature also depend on later variants
    \end{itemize}
  \end{itemize}

\end{frame}



\begin{frame}
  \frametitle{Moments of reflection: compositionality}
  
  \Emph{Conjecture}
  \begin{itemize}
    \item Compositionality probably feasible for simple languages, but not for the complex ones (like Haskell)
  \end{itemize}
  
  What is known about feature composition and their (in)dependence?

  \begin{itemize}
    \item \Emph{ideal}: for every paper |pi, pj| (describing theory, semantics, etc) for feature |fi, fj| there is a paper |pij| for |fi + fj|
    \item \Emph{reality}: there are few |pij|'s
    \begin{itemize}
      \item Left to the implementer (to figure something out)
      % \item Might even require 
    \end{itemize}
  \end{itemize}
  
  \Emph{But still} compositionality is the major mechanism to keep complexity manageable

\end{frame}


%}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Engineering
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Engineering matters}

\begin{frame}
  \frametitle{Engineering: the devil is in the detail (1)}
  
  (The sting is in the tail, before summarizing)
  
  The small seemingly innocent can bite

  \[
  \rulerCmdUse{Lamnochng.D.exp.gen.gen}
  \]
  
  |ftv| traverses |Env|

  \begin{itemize}
    \item |Env| may be large, possibly 'naively' holding all imported modules
    \item Does not scale
  \end{itemize}
  
  Need for incrementality

\end{frame}



\begin{frame}
  \frametitle{Engineering: the devil is in the detail (1)}
  
  Observations: 

  \begin{itemize}
    \item |ftv(Env)| usually is small, empty for each module
    \item |ftv(Env)| can be incrementally computed
  \end{itemize}

  In either case: manual tweaking/optimization required

  \begin{itemize}
    \item Incrementality can be automated\CITE{bransen2015phd-ag-incr}
  \end{itemize}

\end{frame}



\begin{frame}
  \frametitle{Engineering: the devil is in the detail (2)}
  
  Encoding of substitutions
  
  \[
  \rulerCmdUse{Lamnochng.A.exp.core.app}
  \]
  
  Naive encoding eagerly propagates substitution, rebuilding structures

\end{frame}


%{
%%@SlidesCopingComplexity.implPreamble

\begin{frame}
  \frametitle{Engineering: the devil is in the detail (2)}
  
  Invariant: substitution maps in 1 lookup (no indirections)

%%[[wrap=safecode
class Substitutable x where {($->) :: Subst -> x -> x}

instance Substitutable Subst where
  s1 $-> s2 = s1 ++ map (\(v,t) -> (v, s1 $-> t)) s2          ^^ -- $O(n^2)$

instance Substitutable Ty where
  s $-> t = case t of
    TyVar v -> maybe t (s $->) $ lookup v s
    TyArr a r -> TyArr (s $-> a) (s $-> r)

BLGRAY data TyVar  = BLGRAY ...
BLGRAY data Ty     = BLGRAY TyInt | TyVar TyVar | TyArr Ty Ty | ...
BLGRAY type Subst  = BLGRAY [(TyVar,Ty)]
%%]]

  Does \Emph{not scale}: $O(n^2)$ complexity, size of structures increases (duplication when variables occur |>1| times)

\end{frame}


\begin{frame}
  \frametitle{Engineering: the devil is in the detail (2)}
  
  Solution: delay substitution\CITE{UUCS2008027}

%%[[wrap=safecode
instance Substitutable Subst where
  s1 $-> s2 = s1 (RED(++ s2))

instance Substitutable Ty where
  s $-> t = case t of
    TyVar v -> maybe t (s ^^ $->) $ (RED(substLookup v s))
    ...

substLookup v s = lookup v s >>= \t ->
  (tyIsVar t >>= flip substLookup s) <|> return t
%%]]

  Price: all code assuming fully substituted types now can no longer assume this,
  must be passed substitution as additional parameter

\end{frame}


\begin{frame}
  \frametitle{Moments of reflection}
  
  The \Emph{ideal}
  \begin{itemize}
    \item Implementation follows directly from declarative/algorithmic specification
  \end{itemize}
  
  The \Emph{reality}
  \begin{itemize}
    \item Engineering issues (scaling up) require (manual) tweaking
  \end{itemize}
  
  In UHC
  \begin{itemize}
    \item Manual tweaking, making code less readable/understandable
    \item Left unexplored: generated implementation for these idioms (e.g. as part of |Ruler|)
  \end{itemize}
  
\end{frame}


%}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Summary
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Summary}


\begin{frame}
  \frametitle{Summary}
  
  What did we learn from building UHC?
  
  \begin{itemize}
    \item From theory to practice is complex!
    \item Use tools, engineering, dsl's, exploit compositionality
    \item Some complexity can be engineered away, not all
  \end{itemize}

  Contributors
  
  \begin{itemize}
    \item Doaitse Swierstra, Jeroen Fokker, Arie Middelkoop, Marcos Viera, Jeroen Bransen, ...
  \end{itemize}
  
  This talk \& running example demos
  
  \begin{itemize}
    \item Part of \url{https://github.com/atzedijkstra/uhc-doc}
    \item Built using |Shuffle|, |Ruler|, UUAGC, GHC, \lhstex, \latex
  \end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% The rest, leftover material
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%if draft

\begin{frame}


===========================

Here we are
  
===========================
  
\end{frame}


%endif % draft


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Extra stuff
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%if draft

\section*{Additional topics}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type system: non syntax driven complexity
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection*{Type system: non syntax driven complexity}


\begin{frame}
  \frametitle{Type system: non syntax driven complexity}
  
  CHR, red graph, delayed choice

  \begin{itemize}
    \item XX
    \begin{itemize}
      \item XX
    \end{itemize}
    
    \item XX
  \end{itemize}

\end{frame}

%endif % draft


%if draft


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Attribute Grammar: as EDSL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Attribute Grammar: as EDSL}


\begin{frame}
  \frametitle{Attribute Grammar: as EDSL}

  AspectAG
  
  \begin{itemize}
    \item XX
    \begin{itemize}
      \item XX
    \end{itemize}
    
    \item XX
  \end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Attribute Grammar: incrementality
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Attribute Grammar: incrementality}


\begin{frame}
  \frametitle{Attribute Grammar: incrementality}

  \begin{itemize}
    \item XX
    \begin{itemize}
      \item XX
    \end{itemize}
    
    \item XX
  \end{itemize}

\end{frame}


%endif % draft


%%]

%%[bibPreamble
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Preamble for bib refs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[backend=bibtex]{biblatex}
\addbibresource{flops2016-keynote.bib}
%%]

%%[XX
\begin{frame}
  \frametitle{XX}

  \begin{itemize}
    \item XX
    \begin{itemize}
      \item XX
    \end{itemize}
    
    \item Complexity
  \end{itemize}

\end{frame}


%%]
