%%[beamerTheme
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Theme used by beamer
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\usetheme{Singapore}
\usetheme[secheader]{Boadilla}
%\useoutertheme{infolines}
%%]

%%[config
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Config flags
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%let draft = True

%%]

%%[preamble
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Preamble
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\newcommand{\latex}{\LaTeX\xspace}
\newcommand{\latex}{LaTeX}
\newcommand{\lhstex}{Lhs2TeX}

%\barhs
%\setlength{\coderulewidth}{1.5pt}

\newcommand{\CITE}[1]{\footnote{\citetitle{#1}, \citeyear{#1}}}
\newcommand{\CITEU}[1]{\footnote{\citeurl{#1}}}

\newcommand{\Red}[1]{{\color{red}#1}}
\newcommand{\Itl}[1]{\textit{#1}}
\newcommand{\Emph}[1]{\Red{\Itl{#1}}}

%format (RED(x))	= "\Red{" x "}"
%format BLGRAY 	= "\color{lightgray}"

%format Ty_		= "\tau"
%format Env_	= "\Gamma"
%format PEnv_	= "{\cal{P}}"
%format Exp_	= "e"
%format Subst_	= "\theta"
%format subst_	= Subst_
%format Pred_	= "\pi"
%format pred_	= Pred_

%format tvara	= "\alpha"
%format tvarb	= "\beta"
%format tvar	= tvara
%format ty		= Ty_
%format tya		= Ty_ "_a"
%format Ty		= Ty_
%format pty		= "\sigma"
%format PTy		= pty
%format qty		= "\rho"
%format QTy		= qty
%format env		= Env_
%format Env		= Env_
%format penv	= PEnv_
%format PEnv	= PEnv_
%format exp		= "e"
%format Exp		= Exp_
%format subst	= Subst_
%format Subst	= Subst_
%format pred	= Pred_
%format Pred	= Pred_

%format oplus	= "\oplus"
%format otimes	= "\otimes"

%format TyInt	= "Int"

%format :=-		= "\mid"
%format ::-		= "\vDash"
%%]

%%[intro
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Intro
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \frametitle{\Emph{UHC}: Coping with Compiler \Emph{Complexity}}
  
  \begin{itemize}
    \item \Emph{UHC}: Utrecht Haskell Compiler
    \begin{itemize}
      \item Haskell2010 implementation
      \item Primarily intended for play \& experimentation: higher ranked types, partial type signatures, generic deriving, local instances, java(script) backend, ...
      \item Inspiration for tooling
    \end{itemize}
    
    \item \Emph{Complexity}: Dimensions of complexity
    \begin{itemize}
      \item From specification to implementation
      \item From few to many (combined) language features
    \end{itemize}
    
    \item \Emph{Goal}: keep specification as simple as possible
    \begin{itemize}
      \item Compositionality (divide and conquer)
      \item DSL (Domain Specific Language) for recurring problems
      \item Generate (e.g. boilerplate code)
      \item Consistency between specifications
    \end{itemize}
    
  \end{itemize}

\end{frame}


%if draft

\begin{frame}
  \frametitle{From specification to implementation}
  Outline

  \begin{itemize}
    \item Type system
    \item Impl adds computational direction: from rel to fun
    \item Specify as function
    \item Specify as AG
    \item Specify as |Ruler|, DSL, as beefed up AG
    \item Embed AG (Viera)
    \item Issue: repr subst
    \item Issue: free vars, leading to
    \item Optimize via incrementality (Bransen)
    \item Reasoning, CHR as DSL
  \end{itemize}
  
  Theme: use DSLs to cope with complexity

\end{frame}


\begin{frame}
  \frametitle{From few to many (combined) language features}
  UHC language feature ordering

  \begin{itemize}
    \item HM
    \item Higher ranked
    \item Type classes (local instances)
    \item Code gen
    \item ...
    \item Module system
    \item Libraries
    \item Haskell (report) corner cases
    \item Haskell2010
  \end{itemize}
  
  Theme: distinguish aspects/features

\end{frame}

%endif


\begin{frame}
  \frametitle{Today's plan}
  
  \begin{itemize}
  \item Story thread: write a smallish UHC
  \item Observe what is or will be problematic
  \item Solutions tried for UHC, lessons learned, unexplored topics
  \end{itemize}

\end{frame}


\section*{Contents}

\begin{frame}
  \tableofcontents
  
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Example
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Running example}

\begin{frame}
  \frametitle{Demo language}

\begin{itemize}
\item Basic functional language
%%[[wrap=safecode
   exp     ::=     i                       ^^ -- base: int
           |       n                       ^^ -- name reference
           |       exp ^^ exp              ^^ -- application
           |       \n.exp                  ^^ -- abstraction
           |       let n = exp in exp      ^^ -- let binding
%%]]

\item With a Hindley-Milner type system
%%[[wrap=safecode
   ty      ::=     Int | ty -> ty | tvar
   pty     ::=     ty | forall tvar . pty
%%]]
\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Demo language}

\begin{itemize}
\item Language example
%%[[wrap=safecode
let id = \x.x in
let id2 = id id id id in
id id2 (id 5)
%%]]

\item Desired output and results
  \begin{itemize}
  \item Some analysis for some semantics: type
  \item Some error reporting: name errors, type errors
  \item Some code generation using analysis results: pretty printing
  \end{itemize}

\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Demo language}

\begin{itemize}
\item Compiler output

%%[[wrap=verbatimsmall
-- PP
let id : forall a. a -> (a)
       = \x.x in
let id2 : forall a. a -> (a)
        = id (id) (id) (id) in
id (id2) (id (5))
-- Ty
Int
%%]]
\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Demo language}

\begin{itemize}
\item Language example with a name error
%%[[wrap=safecode
let id = \x.y in
f 4
%%]]

\item Compiler output

%%[[wrap=verbatimsmall
-- PP
let id : forall a. a -> (ERR)
       = \x.y{- Not introduced: y -} in
f{- Not introduced: f -} (4)
-- Errors
Not introduced: y
Not introduced: f
%%]]
\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Demo language}

\begin{itemize}
\item Language example with typing error (Y fixpoint combinator)
%%[[wrap=safecode
\w . (\x.w(x x)) (\x.w(x x))
%%]]

\item Compiler output

%%[[wrap=verbatimsmall
-- PP
\w.\x.w (x (x){- Occurs: v2
                         v2 -> (v5) -}
        ) (\x.w (x (x){- Occurs: v8
                                 v8 -> (v11) -}
                )
          )
-- Errors
Occurs: v2
        v2 -> (v5)
Occurs: v8
        v8 -> (v11)
%%]]
\end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type system
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Type system specification}

\begin{frame}
  \frametitle{Writing a compiler for the demo language}
  
  What needs to be done?
  \begin{itemize}
  \item Specify the semantics (here: only type, not operational)
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Type semantics, declarative}

  Hindley-Milner type system (HM), declarative specification for type system
  {\small
  \rulerCmdUse{Lam.D.exp.onslide}
  }
  
  + generalization, instantiation ...

\end{frame}


\begin{frame}
  \frametitle{Type semantics, declarative}

  Generalization, instantiation
  {\small
  \rulerCmdUse{Lam.D.exp.gen}
  }
  
  \pause
  Can we directly implement this?
  \begin{itemize}
  \item When to apply rules?
  \item How to solve equations implied implicitly by multiple occurrences of meta variables (like |tya|)?
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Type semantics, syntax directed}

  For HM this is well known\footnote{\url{https://en.wikipedia.org/wiki/Hindley-Milner_type_system}}
  {\small
  \rulerCmdUse{Lam.SD.exp.onslide.sd}
  }
  
  Add and allow for computational direction
  \begin{itemize}
  \item When to apply rules? Make it syntax directed
  \item How to solve equations? Algorithm W (for example), unification, type variables \& substitution
  \end{itemize}
  
  But...
  \pause
  for an implementation design, algorithm, and engineering decisions have to be made
  
  %Observation: 
  

\end{frame}


\begin{frame}
  \frametitle{Type semantics, algorithmic}
  
  Algorithm W

  {\small
  \rulerCmdUse{Lam.A.exp.onslide}
  }

  Ready to implement...
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Implementation: Haskell
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementation: Haskell}

%{

%%[[implPreamble
%format Ty		= "Ty"
%format ty		= "ty"
%format Env		= "Env"
%format env		= "env"
%format Exp		= "Exp"
%format Subst	= "Subst"
%format subst	= "subst"

%format TyInt	= "TyInt"

%format $->		= $ "_{" Subst_ "}"
%%]]

\begin{frame}
  \frametitle{Implementation}

Haskell implementation of Algorithm W

%%[[wrap=safecode
algoW ::  Env   -> (  Subst, Int)  ->  Exp   -> (  Ty, (   Subst, Int), Err)
          Env_  ;     Subst_       :-  exp   :     Ty_ ~>  Subst_
%%]]

\begin{center}
\begin{tabular}{lll}
\textbf{Type} &  &  \\ \hline
|Env| & |Env_| & scoped environment, mapping from identifiers to types \\
|Exp| & | Exp_| & term AST \\
|Ty| & | Ty_| & types \\
|Int| & & unique number generation, for fresh type variables \\
|Subst| & | Subst_| & substitution, mapping type variables to types \\
|Err| & & errors \\
\end{tabular}
\end{center}

Syntax directed rules now allow pattern match on |Exp| to deterministically choose the right rule

\end{frame}


\begin{frame}
  \frametitle{Implementation, purely functional}

{\small
%%[[wrap=safecode
algoW :: Env -> (Subst, Int) -> Exp -> (Ty, (Subst, Int), Err)
algoW env st (Exp_App f a) =
    (s4 $-> v, (s4, uniq st3), ef ++ ea ++ eu)
  where 
    (tf,  st1, ef)  = algoW env st   f                  ^^ -- recurse for function
    (ta,  st2, ea)  = algoW env st1  a                  ^^ -- recurse for argument
    (v,   st3)      = fresh  st2                        ^^ -- new fresh type var
    s3              = subst  st3                        ^^ -- get current subst
    (su,  eu)       = unify  (s3 $-> tf)                ^^ -- apply subst, unify
                             (TyArr ta v)
    s4              = su $-> s3
    
    BLGRAY -- helper functions
    BLGRAY fresh (s,u) = (mkTyVar u, (s,u+1))
    BLGRAY subst = fst
    BLGRAY uniq = snd
%%]]
}

\end{frame}


\begin{frame}
  \frametitle{Implementation, purely functional}

Utility types (for reference)
{\small
%%[[wrap=safecode
data TyVar  = TV Int ...
data Ty     = TyInt | TyVar TyVar | TyArr Ty Ty | ...
data Exp    = Exp_App  Exp Exp | ...
type Env    = [(String,Ty)]
type Subst  = [(TyVar,Ty)]
class Substitutable x where {($->) :: Subst -> x -> x}
%%]]
}

\end{frame}


\begin{frame}
  \frametitle{Moments of reflection}
  
  What have we done so far?

  \begin{itemize}
    \item Started with concise declarative specification, which
    \begin{itemize}
      \item Via algorithmic version
      \item Led to functional implementation
      \item For which Haskell itself is already a good tool
    \end{itemize}
    \item But...
    \begin{itemize}
      \item Many low level details crept in while still many other details are left out
      \item An actual implementation must do more than just specify semantics: parser, scanner, ...
      \item Implementation for our example: approx 300 LOC (without comment)
    \end{itemize}
    
    \item And...
    \begin{itemize}
      \item We are not done yet...
      \item Pretty printing (as kind of code generation)
      % \item Error gathering
    \end{itemize}
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Moments of reflection}

  Can we \Emph{scale up}?
  
  \begin{itemize}
    \item The things/aspects |a1, a2, ...| we want to specify/compute per language construct?
    \item The number of language features/constructs |f1, f2, ...|?
  \end{itemize}
  
  \pause
  The \Emph{ideal} would be to be able to specify independently

  \begin{itemize}
    \item Aspects |a1| and |a2| and then combine them with some operator |oplus| into |a1 oplus a2|
    \item Language features |f1| and |f2| and then combine them with some operator |otimes| into |f1 otimes f2|
  \end{itemize}
  
  The \Emph{reality} is that aspects, features, and their combination usually must be 'aware' of each other to some degree.
  
  \pause
  \begin{itemize}
    \item Why? How is this mitigated in UHC?
    \item First, we look at combining aspects
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Implementation, pretty printing}
  
  Pretty printing: extra aspect for existing language constructs
  
  \begin{itemize}
    \item The ideal would be to define pretty printing independently of algoW:

%%[[wrap=safecode
pp :: Exp -> Doc
pp (Exp_App f a    )  =  pp f >|< pp a
pp (Exp_Let n e b  )  =  "let"  >|< pp n >|< "=" >|< pp e >|<
                         "in"   >|< pp b

data Doc = ...                      ^^ -- pretty print document
(>|<) :: Doc -> Doc -> Doc          ^^ -- concatenate horizontally
%%]]

  \item This works well if |pp| does not use info encapsulated in |algoW|
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Implementation, pretty printing}
  
  For independent aspects, this
  leads to nanopasses\CITE{Keep:2013:NFC:2520988}\CITE{laemmel03boilerplate}
  in compiler: small, maintainable, isolates solution for single (independent) problem
  
  \begin{itemize}
  \item Used in UHC for (e.g.) transformations of intermediate representations
  \item Can be inefficient, boilerplate overhead
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Implementation, pretty printing}
  
  The reality here is that |pp| and |algoW| are dependent:
  pretty printing uses the inferred type (|te|) and error messages (|eu|) of |algoW|

%%[[wrap=safecode
pp :: Exp -> Doc
pp (Exp_App f a    )  =  pp f >|< pp a (RED( >|< pp eu))
pp (Exp_Let n e b  )  =  "let"  >|< pp n  (RED( >|< ":" >|< pp te >|<))
                                          >|< "=" >|< pp  e >|<
                         "in"   >|< pp b
%%]]

  Aspects type and pretty printing are not independent!

  In general, more complex analyses are dependent.

\end{frame}


\begin{frame}
  \frametitle{Implementation}

  Solution 1: add |pp| to |algoW|:

{\small
%%[[wrap=safecode
algoW :: Env -> (Subst, Int) -> Exp -> (Ty, (Subst, Int), Err(RED(, Doc)))
algoW env st (Exp_App f a) =
    (s4 $-> v, (s4, uniq st3), ef ++ ea ++ eu(RED(, pf >|< pa >|< pp eu)))
  where 
    (tf,  st1, ef(RED(, pf)))  = algoW env st   f    
    (ta,  st2, ea(RED(, pa)))  = algoW env st1  a    
    (su,  eu)                  = unify  (s3 $-> tf) (TyArr ta v)
    ...
%%]]
}

  Refactorization in the 'wrong' direction

  \begin{itemize}
  \item Adding an aspect means a manual overhaul of boilerplate code
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Implementation}

  Solution 2: plumbing via underlying implementation language

\begin{itemize}
\item A monadic interface for Algorithm W
%%[[wrap=safecode
algoW
      ::  (  MonadReader Env m                  ^^ -- scoped name mapping
          ,  MonadState (Subst, Int) m          ^^ -- global state
          ,  MonadError Err m                   ^^ -- error/exception
          (RED(, MonadWriter Doc m))            ^^ -- \Red{pretty printing}
          ) => Exp -> m Ty
%%]]
\item Boilerplate partially done by monad transformer lifting
\item Allows monadic ordering: state left-to-right, by default no mutual recursion, ...
\item Possibly constrained by underlying type system%, may require a monad per aspect
\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Solution 3 (taken by UHC): DSL for computations over ASTs

  \begin{itemize}
  \item Each individual computation expressed as attribute
  \item Specification for each attribute can be separately described, combined later
  \item A compiler (UUAGC) glues separate specifications, generating functional program, including boilerplate
  \end{itemize}

  We can think in terms of attributes associated with parent and children in AST,
  defining data flow fragments
  
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Implementation: AG
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementation: Attribute Grammar (AG)}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Way of thinking and programming now can be different
   
  \begin{itemize}
  \item All computation is defined in terms of attributes associated with parent and children
  \item Attributes are defined in terms of other attributes, thus specifying small dataflow fragments for parent and children
  \end{itemize}
  
  \begin{center}
  \agpictureAtY{4}{2}{flops2016-keynote/lam1env}
  \end{center}

  \begin{itemize}
  \item Inherited attributes 'travel' downwards (from root to leaves), synthesized upwards
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Environment
  
  \begin{center}
  \agpictureScaled{0.5}{flops2016-keynote/lam1env}
  \end{center}

%%[[wrap=safecode
DATA Exp                                    ^^ -- AST
  | App     f     : Exp
            a     : Exp

ATTR Exp [ env: Env | | ]                   ^^ -- inherited, from root to leaves

SEM Exp
  | App     f   .   env     =   @lhs.env    ^^ -- copied downwards
            a   .   env     =   @lhs.env
%%]]

Boilerplate copying (for |env|) usually omitted and generated automatically

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Unique number generation
  
  \begin{center}
  \agpictureAtY{8}{4}{flops2016-keynote/lam1uniq}
  \end{center}

%%[[wrap=safecode
ATTR Exp [ | uniq: Int | ]                   ^^ -- synthesized + inherited = state

SEM Exp
  | App     loc     .   v       =   mkTyVar @lhs.uniq
            f       .   uniq    =   @lhs.uniq + 1
%%]]

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Substitution
  
  \begin{center}
  \agpictureAtY{10}{5}{flops2016-keynote/lam1subst}
  \end{center}

%%[[wrap=safecode
ATTR Exp [ | subst: Subst | ]
%%]]

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Substitution, type, unification
  
  \begin{center}
  \agpictureAtY{12}{7}{flops2016-keynote/lam1ty}
  \end{center}

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  \begin{center}
  \agpictureScaledAtY{11}{6}{0.5}{flops2016-keynote/lam1ty}
  \end{center}

%%[[wrap=safecode
ATTR Exp [ | | ty: Ty ]     ^^ -- synthesized

SEM Exp
  | App  (loc.su,loc.eu)   =  unify  (@a.subst $-> @f.ty)
                                     (TyArr @a.ty @v)
         loc  .  s4        =  @su $-> @a.subst
         lhs  .  ty        =  @s4 $-> @v
              .  subst     =  @s4
%%]]

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Error collecting
  
  \begin{center}
  \agpictureAtY{8}{4}{flops2016-keynote/lam1err}
  \end{center}

%%[[wrap=safecode
ATTR Exp [ | | err : Err ]

SEM Exp
  | App				lhs	.	err		=	@eu ++ @f.err ++ @a.err
%%]]

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Similarly: pretty printing
  
  \begin{center}
  \agpictureAtY{7}{3}{flops2016-keynote/lam1ppApp}
  \agpicture{flops2016-keynote/lam1ppLam}
  \end{center}

%%[[wrap=safecode
ATTR Exp [ | | pp : Doc ]

SEM Exp
  | App				lhs	.	pp		=	@f.pp >|< @a.pp >|< ppErr @eu
  | Lam				lhs	.	pp		=	"\\" >|< @n >|< "." >|< @exp.pp
%%]]

(Ignoring layout details)

\end{frame}


\begin{frame}
  \frametitle{Moments of reflection}
  
  What have we done so far?

  \begin{itemize}
    \item Started with concise declarative specification, which
    \begin{itemize}
      \item Via algorithmic version
      \item Led to Attribute Grammar implementation
      \item Where all aspects can be described independently even though there are dependencies
      \item Generates Haskell using UUAGC (UU AG compiler)
      \item Combines separate specifications, generates boilerplate code
    \end{itemize}
    \item This works very well!
    \begin{itemize}
      \item In UHC, almost all functionality involving trees is expressed using AGs
      \item Integrates with Haskell ecosystem
    \end{itemize}
  \end{itemize}

  \pause
  But...

\end{frame}


\begin{frame}
  \frametitle{Moments of reflection}
  
  Drawbacks

  \begin{itemize}
    \item We still have to know about dependencies
    \begin{itemize}
      \item Luckily, UUAGC gives feedback about dependency related errors
    \end{itemize}
    \item UUAGC is a preprocessor: checks for AG specifics, but not Haskell specifics of embedded Haskell code
    \begin{itemize}
      \item We get Haskell errors too late, only when generated code is compiled
    \end{itemize}
    \item One has to learn a separate language
    \begin{itemize}
      \item And the additional tooling etc.
    \end{itemize}
    \item Implementation done manually, what guarantees do we have about consistency with type rules?
    \begin{itemize}
      \item Maintaining two copies of the same is a nightmare
    \end{itemize}    
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Moments of reflection}

  What can we do to \Emph{guarantee} easier change?
  
  \begin{itemize}
    \item One DSL for both type rules and implementation of them
    \item Embed DSLs, allowing better error reporting
  \end{itemize}
  
  \pause
  The \Emph{ideal} would be to be able to specify declaratively

  \begin{itemize}
    \item The type system, with 'magic' figuring out a corresponding implementation
    \item An implementation using various DSLs inside one host language
  \end{itemize}
  
  The \Emph{reality} is that type systems soon are too complex,
  'magic' does not exist, embedding DSLs is still ongoing research,
  and an implementation involves usually |>1| host languages
  
  \pause
  \begin{itemize}
    \item Why? How is this mitigated in UHC?
    \item First, we look at consistency between type rules and implementation
  \end{itemize}
  

\end{frame}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Implementation: |Ruler|
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementation: |Ruler|}


\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  Specification of type semantics often done in \latex
  
  \[
  \rulerCmdUse{Lamnochng.A.exp.core.app}
  \]

  But ...
  \\ Is \latex\ (+ \lhstex) a good specification language for type rules?

\end{frame}


\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  \latex\ + \lhstex:

%%[[latexForRulerRuleAppA
{\tiny
%%[[wrap=verbatim
\rulerRule{app}{A}
{ | tvar | \;\mbox{fresh} | |
\\| subst ; env :- f : ty | _{ | f |} | ~> subst | _{ | f |} | |
\\| subst | _{ | a |} | ty | _{ | f |} | === ty | _{ | a |} | -> tvar ~> subst | _{ | u |} | |
\\| subst | _{ | f |} | ; env :- a : ty | _{ | a |} | ~> subst | _{ | a |} | |
 }
{ | subst ; env :- f ^^ a : subst | _{ | u |} | tvar ~> subst | _{ | u |} | subst | _{ | a |} | | }
%%]]
}
%%]]

Gives us pretty rendering in papers and (these) slides...

But...

  \begin{itemize}
    \item Mixup of specification \& rendering
    \item Check for identifier introduction?
    \item Judgement conforms to its required structure?
    \item Typing of type rules?
  \end{itemize}

And...

\end{frame}


\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  How can we keep type rules and their implementation consistent?
  
  \[
  \rulerCmdUse{Lamnochng.A.exp.core.app}
  \]

{\small
%%@Lam_A_ruler.2.exp.app wrap=safecode
}

\end{frame}


\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  In general, given a specification for some semantics, we (want to)
  
  \begin{enumerate}
    \item \label{semgenrender} Render it for \Emph{human reading} \& reasoning,
    \item \label{semgenreason} Feed it into \Emph{theorem proving} machinery for (automated/mechanized) reasoning,
    \item \label{semgenexec} Generate code for \Emph{actual execution} (of e.g. a checker)
  \end{enumerate}
  
  The \Emph{ideal} would be to obtain all 3 from a single description.
  
  The \Emph{reality} is that for a given tool we get (approx) 2 out of 3...
  
  \vspace{2ex} \pause
  For UHC, |Ruler| gives us \ref{semgenrender} \& \ref{semgenexec}:
  previous slide contains generated rendering and AG code

\end{frame}



\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  One specification from which everything else is generated
  
  Not a new idea:
  
  \begin{center}
  \begin{tabular}{l||p{.17\linewidth}p{.17\linewidth}p{.17\linewidth}p{.17\linewidth}}
                  & \multicolumn{4}{l}{ \textbf{Generates for, or implements}} \\
  \textbf{System} &  \textbf{\latex} &  \textbf{mechanized reasoning} &  \textbf{verified code} & \textbf{verifying code} \\ \hline
  Ott\CITE{sewell2010ott-jfp} & \checkmark & \checkmark & & \\
  Coq\CITEU{Anonymous:J735rZAA} & \checkmark & \checkmark & \checkmark (extraction) & \\
  |Ruler|\CITE{dijkstra06ruler} & \checkmark & & & \checkmark (AG checker) \\
  \end{tabular}
  \end{center}
  
  But...
  
\end{frame}



\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  Generating a checker for type rules (i.e. code which verifies) is rather difficult
  
  \begin{itemize}
    \item Why? How did we experiment with |Ruler| in UHC? What is |Ruler|?
    \item First, we look at |Ruler|
  \end{itemize}
  
\end{frame}



\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  |Ruler|
  
  \begin{itemize}
    \item Specify rules
    \item Generate \latex\ and/or AG code
  \end{itemize}
  
  The \Emph{good news}

  \begin{itemize}
    \item Example in these slides is generated from a single |Ruler| specification (+ additional helper code)
  \end{itemize}
  
  %For example...

  
\end{frame}



%{
%format exp		= "exp"

\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  |Ruler| example

%%@HMDemoLam.schemeExp wrap=safecode

Specifies

  \begin{itemize}
    \item for the view |D| (declarative)
    \item the 'type' of judgements for |exp|,
    \item its parsing, and
    \item \latex\ rendering
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  |Ruler| example

%%@HMDemoLam.ruleAppViewD wrap=safecode

  Specifies a single rule instance |app| of scheme (type) |exp|

  %Generates...

\end{frame}


\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  Generates (already seen)

%%@SlidesCopingComplexity.latexForRulerRuleAppA

  which with a little help from \lhstex\ renders as (also already seen)

  {\small
  \rulerCmdUse{Lam.D.exp.onslideApp}
  }
  
\end{frame}


\begin{frame}
  \frametitle{Implementation: |Ruler|}
    
  The \Emph{bad news}

  \begin{itemize}
    \item |Ruler| can generate only when rules are algorithmic and syntax driven
    \item Which the declarative variant of our example is not, so
    \item We have to add additional info or override existing to arrive at a rule from which we can generate AG
  \end{itemize}

  |Ruler| provides mechanisms for additional or replacement specification to obtain

  \begin{center}
  \begin{tabular}{p{.4\linewidth}p{.4\linewidth}}
  {\small
  \rulerCmdUse{Lam.D.exp.core.app}
  }
  &
  {\small
  \rulerCmdUse{Lam.A.exp.core.app}
  }
  \\
  \end{tabular}
  \end{center}
  
  
\end{frame}


\begin{frame}
  \frametitle{Implementation: |Ruler|}
    
  %The \Emph{worse news}
  The \Emph{really bad news}
  \begin{itemize}
    \item Rules being algorithmic and syntax driven is not enough for many type systems
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  Why is it that rules being algorithmic and syntax driven is not enough for many type systems?
  \begin{itemize}
    \item Deterministic vs. non-deterministic!
  \end{itemize}
    
  When is non-determinism \Emph{present} and/or \Emph{required}?
  \begin{itemize}
    \item In Hindley-Milner type system example non-deterministism is present, but not required, because we can transform it to
    \item Algorithm W: deterministic, because rule choice is syntax driven, algorithmic because relationships have direction (are functions, computable)
  \end{itemize}
  
  \pause
  But
  \begin{itemize}
    \item Haskell type class system cannot be dealt with in a syntax driven way
  \end{itemize}

  Let's look at its rules and see why...
    

\end{frame}


%}

%}



\begin{frame}
  \frametitle{Example: Haskell type class system}
  
Haskell type class system

\begin{itemize}
\item Haskell example
%%[[wrap=safecode
   class Eq a where
     (==) :: a -> a -> Bool
   instance Eq Int where ...
   instance Eq a => Eq [a] where ...
   
   f :: Eq a => a -> a -> Bool          ^^ -- specified or inferred
   f x y = x == y && x == y             ^^ -- just an example
%%]]

\item Extension of running example with qualified types
%%[[wrap=safecode
   ty      ::=     Int | ty -> ty | tvar        ^^
   qty     ::=     ty | pred => qty             ^^ -- qualified
   pred    ::=     Eq ty | ...
   pty     ::=     qty | forall tvar . pty
%%]]
\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Example: Haskell type class system}
  
  Extension of Hindley-Milner type system\CITE{jones94phd-qual-types}, declaratively
  {\small
  \rulerCmdUse{Lam.Q.exp.onslide}
  }
  
  \begin{itemize}
    \item |PEnv| : assumed (i.e. given, true, ...) type class predicates
    \begin{itemize}
      \item E.g. |Eq Int, Eq a => Eq [a]|
    \end{itemize}
    \item Almost independent extension of HM ...
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Example: Haskell type class system}
  
  Only need to tweak generalization
  
  {\small
  \rulerCmdUse{Lam.Q.exp.gen}
  }

\end{frame}


\begin{frame}
  \frametitle{Example: Haskell type class system}
  
  Additional rules for predicate introduction and elimination
  {\small
  \rulerCmdUse{Lam.Q.exp.pred}
  }
  
  Entailment |penv ::- pred|
  
  \pause
  \begin{itemize}
    \item Usual rules: transitivity, ...
    \item Rules derived from class/instance definitions
    \item Requires a small theorem prover
    \begin{itemize}
      \item E.g. to derive |Eq [Int]| from |Eq Int, Eq a => Eq [a]|
    \end{itemize}
  \end{itemize}

  \pause
  So, why is this a problem?
  

\end{frame}


\begin{frame}
  \frametitle{Example: Haskell type class system}
  
  Can we make the rules syntax directed and algorithmic?
  \begin{itemize}
    \item To some degree, but...
    \begin{itemize}
      \item Direction of |PEnv| is inherited: classes and instances are given
      \item Direction of |PEnv| is synthesized: during type inference occurrences of identifiers give rise to |pred|s
      \item Predicates |pred| may involve type variables for which we 'later' find substitutions
    \end{itemize}
    \item Theorem proving (context reduction) usually ends up being done in |let| expression, before generalization
    \begin{itemize}
      \item Constraint solving: gather constraints syntax directed, prove somewhere else
      \item Need results still at location where constraint arose
    \end{itemize}
  \end{itemize}
  
  But ...
  
  \pause
  \begin{itemize}
    \item The more complex a type system, the more must be done via constraint solving
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Implementation: |Ruler|}
    
  %The \Emph{worse news}
  Back to the \Emph{really bad news}
  \begin{itemize}
    \item Rules being algorithmic and syntax driven is not enough for many type systems
  \end{itemize}
  
  Solutions:
  \pause
  \begin{itemize}
    \item Just a Prolog program!
    \begin{itemize}
      \item Can we really live with the resulting inefficiencies?
    \end{itemize}
    \item Paradigm mix: deterministic (syntax directed) AG-like and non-deterministic (logic programming, constraint solving, backtracking) Prolog-like programming
    \begin{itemize}
      \item Given a declarative set of (type) rules, can we figure out what can be done using which paradigm?
    \end{itemize}
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Implementation: multiple visits/passes}
    
  Solutions explored in the context of UHC and UUAGC:

  Implementation mechanisms\CITE{middelkoop2012phd-ag-visit}
  for which a combi of AG and constraint solving solutions can be generated
  \begin{itemize}
    \item Explicit scheduling for attribute evaluation: sequence of visits/passes
    \begin{itemize}
      \item Each visit/pass a coroutine
    \end{itemize}
    \item Can be invoked syntax directed or uncoupled from syntax (as part of constraint solving)
    \item Can backtrack; can give partial results
  \end{itemize}
  
  But...
  \pause
  \begin{itemize}
    \item 
      Left unexplored: design of a |Ruler| successor which allows declarative and algorithmic part to be independently specified,
      thus avoiding 'pollution' of declarative part
  \end{itemize}
  
\end{frame}


%{
%%@SlidesCopingComplexity.implPreamble

\begin{frame}
  \frametitle{Implementation: multiple visits/passes}
  
  Example: need for visits/passes
  
  \begin{itemize}
    \item Small change in running example: pretty print of lambda expression should include inferred type
    \item Input
%%[[wrap=safecode
((\x.x) 5)
%%]]
    \item Should pretty print to
%%[[wrap=verbatim
(\x:Int.x) (5)
%%]]
    \item We know the type: type variable + substitution
  \end{itemize}

  Substitution |subst| only known after type inference of whole program is done: pass final |subst| (as |substFin|) from |Root| downwards as 2nd pass/visit

\end{frame}


\begin{frame}
  \frametitle{Implementation: multiple visits/passes}
  
  \begin{center}
  \agpictureScaled{0.7}{flops2016-keynote/lam1finsubstRoot}
  \agpictureScaledAtY{8}{3}{0.7}{flops2016-keynote/lam1finsubstLam}
  \end{center}

%%[[wrap=safecode
ATTR Exp [ substFin: Subst | | ]

SEM Root
  | Root            exp .   substFin    =   @exp.subst

SEM Exp
  | Lam             lhs .   pp          =   "\\"  >|< @n
                                                  >|< ":" >|< pp (@lhs.substFin $-> @v)
                                                  >|< "." >|< @exp.pp
%%]]  
    
\end{frame}


\begin{frame}
  \frametitle{Implementation: multiple visits/passes}
  
  UUAGC analyses dependencies to figure out that there are 2 visits

{\tiny
%%[[wrap=safecode
type T_Exp = Env -> Subst -> Int -> (Subst,Ty,Int,T_Exp_1)                                      ^^ -- 1st visit (type)
type T_Exp_1 = Subst -> ( Err,PP_Doc)                                                           ^^ -- 2nd visit (type)
sem_Exp_App :: T_Exp -> T_Exp -> T_Exp                                                          ^^ -- 1st visit
sem_Exp_App f_ a_ = \ _lhsIenv _lhsIsubst _lhsIuniq ->
  let     BLGRAY (_fOuniq,_uniq1) = rulerMk1Uniq _lhsIuniq
  BLGRAY  BLGRAY ( _fIsubst,_fIty,_fIuniq,f_1) = f_ _lhsIenv _lhsIsubst _fOuniq
  BLGRAY  BLGRAY _tvar_ = mkTyVar _uniq1
  BLGRAY  BLGRAY ( _aIsubst,_aIty,_aIuniq,a_1) = a_ _lhsIenv _fIsubst _fIuniq
  BLGRAY  BLGRAY (_subst_u_,_errUnify) = unify (_aIsubst $-> _fIty) (TyArr _aIty _tvar_)    ^^
          sem_Exp_1 = \ _lhsIsubstFin ->                                                    ^^ -- 2nd visit
  BLGRAY  BLGRAY   BLGRAY let  BLGRAY ( _aIerr,_aIpp) = a_1 _lhsIsubstFin
  BLGRAY  BLGRAY   BLGRAY      BLGRAY ( _fIerr,_fIpp) = f_1 _lhsIsubstFin
  BLGRAY  BLGRAY   BLGRAY in   BLGRAY ( _errUnify ++ _fIerr ++ _aIerr
  BLGRAY  BLGRAY   BLGRAY      BLGRAY , _fIpp >#< ppParens _aIpp >|< ppErr _errUnify )
  in      BLGRAY (  BLGRAY _subst_u_ $-> _aIsubst, _subst_u_ $-> _tvar_
  BLGRAY  BLGRAY ,  BLGRAY _aIuniq
          BLGRAY ,  sem_Exp_1 )
%%]]  
}

  Personal opinion: happy not to have to write this manually...

\end{frame}


%}
  

\begin{frame}
  \frametitle{Implementation: multiple visits/passes}
  
  Example, statistics for UHC
  \begin{itemize}
    \item For analysis of expression terms: 8 visits
    \begin{center}
    \begin{tabular}{l||p{.5\linewidth}lll}
       &  & \multicolumn{3}{l}{\textbf{nr of}} \\ 
       & \textbf{deals with} & \textbf{inh} & \textbf{syn} & \textbf{inh+syn} \\ \hline
        0 & source text info & & & 1 \\
        1 & unique (fresh) identifier generation & & 1 & 1 \\
        2 & type/kind env & 3 & & 1 \\
        3 & kind/polarity inference/checking & 6 & & 3 \\
        4 & class env, final type/kind env, datatype gathering & 4 & & 1 \\
        5 & new class/instance gathering & 1 & 4 & \\
        6 & CHR env, value env, type inference & 8 & 5 & 1 \\
        7 & final value env, error gathering, ...  & 9 & 31 & 1 \\ \hline
          &  & 31 & 41 & 9 \\
    \end{tabular}
    \end{center}
  \end{itemize}
  
\end{frame}

  

\begin{frame}
  \frametitle{Moments of reflection: UUAGC, |Ruler|, (non)determinism}
  
  UUAGC
  
  \begin{itemize}
    \item Great for 'tree-oriented' programming: syntax directed, deterministic
    \item Dependency analysis gives efficient (strict) visit based code
    \item Independent specifications for attributes are combined
    \item Generates boilerplate code
    \item Manages \Emph{complexity} of aspects
  \end{itemize}
  
  Used a lot in UHC, and in other tools as well

\end{frame}


\begin{frame}
  \frametitle{Moments of reflection: UUAGC, |Ruler|, (non)determinism}
  
  |Ruler|
  
  \begin{itemize}
    \item In addition to UUAGC: pretty (\latex) printing of type rules
    \item Inspired exploration of visits as target machine model for checkers using syntax directedness, constraint solving, and backtracking
  \end{itemize}
  
  But, as it is, |Ruler| not used anymore in UHC as it offers too little on top of UUAGC

  Management of \Emph{complexity} (of choice) of implementation mechanisms: still unresolved

\end{frame}


\begin{frame}
  \frametitle{Moments of reflection: UUAGC, |Ruler|, (non)determinism}
  
  Nondeterminism
  
  \begin{itemize}
    \item In declarative specification (of rules)
    \begin{itemize}
      \item Convert to algorithmic specification
      \item The \Emph{ideal} would be to annotate (in |Ruler|) which mechanism (|`elem` {|syntax directedness, unification, constraint solving, ...|}|) should be used
    \end{itemize}
    \item In the language (for which we specify rules)
    \begin{itemize}
      \item Language specification may allow ambiguity
      \item In Haskell: higher ranked types, overlapping instances, (in UHC) local instances
      \item Language mechanisms for explicitly disambiguating: type signatures, functional dependencies, (in UHC) named instances
      \item The \Emph{ideal} programming language should offer for each implicit mechanism possibly leading to ambiguity an explicit mechanism for disambiguation
    \end{itemize}
  \end{itemize}
  

\end{frame}



\begin{frame}


===========================

Here we are
  
===========================
  
\end{frame}



\begin{frame}
  \frametitle{Implementation: |Ruler|}
  
  Generating a checker for type rules (i.e. code which verifies) is rather difficult
  Some answers
  \begin{itemize}
    \item One could generate a Prolog (or similar logic) program, however
    \begin{itemize}
      \item This might involve (too much) backtracking, be too inefficient
    \end{itemize}
    \item One could generate a more efficient mix of deterministic (syntax driven) AG like code and nondeterministic Prolog like code, however
    \begin{itemize}
      \item Need to find out which part of a set of rules can be done deterministically, which part not
      \item For example...
    \end{itemize}
  \end{itemize}

\end{frame}








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type system: non syntax driven complexity
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Type system: non syntax driven complexity}


\begin{frame}
  \frametitle{Type system: non syntax driven complexity}

  \begin{itemize}
    \item XX
    \begin{itemize}
      \item XX
    \end{itemize}
    
    \item XX
  \end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Language variants: Shuffle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Language variants: Shuffle}


\begin{frame}
  \frametitle{Language variants: Shuffle}

  \begin{itemize}
    \item XX
    \begin{itemize}
      \item XX
    \end{itemize}
    
    \item XX
  \end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Attribute Grammar: as EDSL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Attribute Grammar: as EDSL}


\begin{frame}
  \frametitle{Attribute Grammar: as EDSL}

  \begin{itemize}
    \item XX
    \begin{itemize}
      \item XX
    \end{itemize}
    
    \item XX
  \end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Attribute Grammar: incrementality
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Attribute Grammar: incrementality}


\begin{frame}
  \frametitle{Attribute Grammar: incrementality}

  \begin{itemize}
    \item XX
    \begin{itemize}
      \item XX
    \end{itemize}
    
    \item XX
  \end{itemize}

\end{frame}


%%]

%%[bibPreamble
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Preamble for bib refs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{biblatex}
\addbibresource{flops2016-keynote.bib}
%%]

%%[XX
\begin{frame}
  \frametitle{XX}

  \begin{itemize}
    \item XX
    \begin{itemize}
      \item XX
    \end{itemize}
    
    \item Complexity
  \end{itemize}

\end{frame}


%%]
