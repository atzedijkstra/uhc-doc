%%[beamerTheme
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Theme used by beamer
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\usetheme{Singapore}
\usetheme[secheader]{Boadilla}
%\useoutertheme{infolines}
%%]

%%[preamble
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Preamble
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\newcommand{\latex}{\LaTeX\xspace}
\newcommand{\latex}{LaTeX}
\newcommand{\lhstex}{Lhs2TeX}

%\barhs
%\setlength{\coderulewidth}{1.5pt}

\newcommand{\CITE}[1]{\footnote{\citetitle{#1}, \citeyear{#1}}}

\newcommand{\Red}[1]{{\color{red}#1}}
\newcommand{\Itl}[1]{\textit{#1}}
\newcommand{\Emph}[1]{\Red{\Itl{#1}}}

%format (RED(x))	= "\Red{" x "}"
%format BLGRAY 	= "\color{lightgray}"

%format Ty_		= "\tau"
%format Env_	= "\Gamma"
%format Exp_	= "e"
%format Subst_	= "\theta"
%format subst_	= Subst_

%format tvara	= "\alpha"
%format tvarb	= "\beta"
%format tvar	= tvara
%format ty		= Ty_
%format tya		= Ty_ "_a"
%format Ty		= Ty_
%format pty		= "\sigma"
%format PTy		= pty
%format env		= Env_
%format Env		= Env_
%format exp		= "e"
%format Exp		= Exp_
%format subst	= Subst_
%format Subst	= Subst_

%format oplus	= "\oplus"
%format otimes	= "\otimes"

%format TyInt	= "Int"
%%]

%%[intro
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Intro
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \frametitle{\Emph{UHC}: Coping with Compiler \Emph{Complexity}}
  
  \begin{itemize}
    \item \Emph{UHC}: Utrecht Haskell Compiler
    \begin{itemize}
      \item Haskell2010 implementation
      \item Primarily intended for play \& experimentation: higher ranked types, partial type signatures, generic deriving, local instances, java(script) backend, ...
      \item Inspiration for tooling
    \end{itemize}
    
    \item \Emph{Complexity}: Dimensions of complexity
    \begin{itemize}
      \item From specification to implementation
      \item From few to many (combined) language features
    \end{itemize}
    
    \item \Emph{Objective}: keep specification as simple as possible
    \begin{itemize}
      \item DSL (Domain Specific Language) for recurring problems
      \item Generate boilerplate code
      \item Consistency between specifications
    \end{itemize}
    
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{From specification to implementation}
  Outline

  \begin{itemize}
    \item Type system
    \item Impl adds computational direction: from rel to fun
    \item Specify as function
    \item Specify as AG
    \item Specify as Ruler, DSL, as beefed up AG
    \item Embed AG (Viera)
    \item Issue: repr subst
    \item Issue: free vars, leading to
    \item Optimize via incrementality (Bransen)
    \item Reasoning, CHR as DSL
  \end{itemize}
  
  Theme: use DSLs to cope with complexity

\end{frame}


\begin{frame}
  \frametitle{From few to many (combined) language features}
  UHC language feature ordering

  \begin{itemize}
    \item HM
    \item Higher ranked
    \item Type classes (local instances)
    \item Code gen
    \item ...
    \item Module system
    \item Libraries
    \item Haskell (report) corner cases
    \item Haskell2010
  \end{itemize}
  
  Theme: distinguish aspects/features

\end{frame}

\begin{frame}
  \frametitle{Today's plan}
  
  \begin{itemize}
  \item Write a smallish UHC
  \item Observe what is or will be problematic
  \item Solutions tried for UHC \& lessons learned
  \end{itemize}

\end{frame}


\section*{Contents}

\begin{frame}
  \tableofcontents
  
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Example
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Running example}

\begin{frame}
  \frametitle{Demo language}

\begin{itemize}
\item Basic functional language
%%[[wrap=safecode
   exp     ::=     i                       ^^ -- base: int
           |       n                       ^^ -- name reference
           |       exp ^^ exp              ^^ -- application
           |       \n.exp                  ^^ -- abstraction
           |       let n = exp in exp      ^^ -- let binding
%%]]

\item With a Hindley-Milner type system
%%[[wrap=safecode
   ty      ::=     Int | ty -> ty | tvar
   pty     ::=     ty | forall tvar . pty
%%]]
\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Demo language}

\begin{itemize}
\item Language example
%%[[wrap=safecode
let id = \x.x in
let id2 = id id id id in
id id2 (id 5)
%%]]

\item Desired output and results
  \begin{itemize}
  \item Some analysis for some semantics: type
  \item Some error reporting: name errors, type errors
  \item Some code generation using analysis results: pretty printing
  \end{itemize}

\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Demo language}

\begin{itemize}
\item Compiler output

%%[[wrap=verbatimsmall
-- PP
let id : forall a. a -> (a)
       = \x.x in
let id2 : forall a. a -> (a)
        = id (id) (id) (id) in
id (id2) (id (5))
-- Ty
Int
%%]]
\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Demo language}

\begin{itemize}
\item Language example with a name error
%%[[wrap=safecode
let id = \x.y in
f 4
%%]]

\item Compiler output

%%[[wrap=verbatimsmall
-- PP
let id : forall a. a -> (ERR)
       = \x.y{- Not introduced: y -} in
f{- Not introduced: f -} (4)
-- Errors
Not introduced: y
Not introduced: f
%%]]
\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Demo language}

\begin{itemize}
\item Language example with typing error (Y fixpoint combinator)
%%[[wrap=safecode
\w . (\x.w(x x)) (\x.w(x x))
%%]]

\item Compiler output

%%[[wrap=verbatimsmall
-- PP
\w.\x.w (x (x){- Occurs: v2
                         v2 -> (v5) -}
        ) (\x.w (x (x){- Occurs: v8
                                 v8 -> (v11) -}
                )
          )
-- Errors
Occurs: v2
        v2 -> (v5)
Occurs: v8
        v8 -> (v11)
%%]]
\end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type system
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Type system specification}

\begin{frame}
  \frametitle{Writing a compiler for the demo language}
  
  What needs to be done?
  \begin{itemize}
  \item Specify the semantics (here: only type, not operational)
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Type semantics, declarative}

  Hindley-Milner type system (HM), declarative specification for type system
  {\small
  \rulerCmdUse{Lam.D.exp.onslide}
  }
  
  + generalization, instantiation ...

\end{frame}


\begin{frame}
  \frametitle{Type semantics, declarative}

  Generalization, instantiation
  {\small
  \rulerCmdUse{Lam.D.exp.gen}
  }
  
  \pause
  Can we directly implement this?
  \begin{itemize}
  \item When to apply rules?
  \item How to solve equations implied implicitly by multiple occurrences of meta variables (like |tya|)?
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Type semantics, syntax directed}

  For HM this is well known\footnote{\url{https://en.wikipedia.org/wiki/Hindley-Milner_type_system}}
  {\small
  \rulerCmdUse{Lam.SD.exp.onslide.sd}
  }
  
  Add and allow for computational direction
  \begin{itemize}
  \item When to apply rules? Make it syntax directed
  \item How to solve equations? Algorithm W (for example), unification, type variables \& substitution
  \end{itemize}
  
  But...
  \pause
  for an implementation more and more design, algorithmic, and engineering decisions have to be made
  
  %Observation: 
  

\end{frame}


\begin{frame}
  \frametitle{Type semantics, algorithmic}
  
  Algorithm W

  {\small
  \rulerCmdUse{Lam.A.exp.onslide}
  }

  Ready to implement...
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Implementation: Haskell
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementation: Haskell}

%{

%format Ty		= "Ty"
%format ty		= "ty"
%format Env		= "Env"
%format env		= "env"
%format Exp		= "Exp"
%format Subst	= "Subst"
%format subst	= "subst"

%format TyInt	= "TyInt"

%format $->		= $ "_{" Subst_ "}"

\begin{frame}
  \frametitle{Implementation}

Haskell implementation of Algorithm W

%%[[wrap=safecode
algoW ::  Env   -> (  Subst, Int)  ->  Exp   -> (  Ty, (   Subst, Int), Err)
          Env_  ;     Subst_       :-  exp   :     Ty_ ~>  Subst_
%%]]

\begin{center}
\begin{tabular}{lll}
\textbf{Type} &  &  \\ \hline
|Env| & |Env_| & scoped environment, mapping from identifiers to types \\
|Exp| & | Exp_| & term AST \\
|Ty| & | Ty_| & types \\
|Int| & & unique number generation, for fresh type variables \\
|Subst| & | Subst_| & substitution, mapping from type variables to types \\
|Err| & & errors \\
\end{tabular}
\end{center}

Syntax directed rules now allow pattern match on |Exp|

\end{frame}


\begin{frame}
  \frametitle{Implementation, purely functional}

{\small
%%[[wrap=safecode
algoW :: Env -> (Subst, Int) -> Exp -> (Ty, (Subst, Int), Err)
algoW env st (Exp_App f a) =
    (s4 $-> v, (s4, uniq st3), ef ++ ea ++ eu)
  where 
    (tf,  st1, ef)  = algoW env st   f                  ^^ -- recurse for function
    (ta,  st2, ea)  = algoW env st1  a                  ^^ -- recurse for argument
    (v,   st3)      = fresh  st2                        ^^ -- new fresh type var
    s3              = subst  st3                        ^^ -- get current subst
    (su,  eu)       = unify  (s3 $-> tf)                ^^ -- apply subst, unify
                             (TyArr ta v)
    s4              = su $-> s3
    
    BLGRAY -- helper functions
    BLGRAY fresh (s,u) = (mkTyVar u, (s,u+1))
    BLGRAY subst = fst
    BLGRAY uniq = snd
%%]]
}

\end{frame}


\begin{frame}
  \frametitle{Implementation, purely functional}

Utility types (for reference)
{\small
%%[[wrap=safecode
data TyVar  = TV Int ...
data Ty     = TyInt | TyVar TyVar | TyArr Ty Ty | ...
data Exp    = Exp_App  Exp Exp | ...
type Env    = [(String,Ty)]
type Subst  = [(TyVar,Ty)]
class Substitutable x where {($->) :: Subst -> x -> x}
%%]]
}

\end{frame}


\begin{frame}
  \frametitle{Moments of reflection}
  
  What have we done so far?

  \begin{itemize}
    \item Started with concise declarative specification, which
    \begin{itemize}
      \item Via algorithmic version
      \item Led to functional implementation
      \item For which Haskell itself is already a good match
    \end{itemize}
    \item But...
    \begin{itemize}
      \item Many low level details crept in while still many details are left out
      \item An actual implementation must do more than just specify semantics: parser, scanner, ...
      \item Implementation for our example: approx 300 LOC (without comment)
    \end{itemize}
    
    \item And...
    \begin{itemize}
      \item We are not done yet...
      \item Pretty printing
      % \item Error gathering
    \end{itemize}
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Moments of reflection}

  Can we \Emph{scale up}?
  
  \begin{itemize}
    \item The things/aspects we want to specify/compute per language construct?
    \item The number of language constructs?
  \end{itemize}
  
  \pause
  The \Emph{ideal} would be to be able to specify independently

  \begin{itemize}
    \item Aspects |a1| and |a2| and then combine them with some operator |oplus| into |a1 oplus a2|
    \item Language features |f1| and |f2| and then combine them with some operator |otimes| into |f1 otimes f2|
  \end{itemize}
  
  The \Emph{reality} is that aspects, features, and their combination usually must be 'aware' of each other to some degree.
  
  \pause
  \begin{itemize}
    \item Why? How is this mitigated in UHC?
    \item First, we look at combining aspects
  \end{itemize}
  

\end{frame}


\begin{frame}
  \frametitle{Implementation, pretty printing}
  
  The ideal would be to define pretty printing independently of algoW:

%%[[wrap=safecode
pp :: Exp -> Doc
pp (Exp_App f a    )  =  pp f >|< pp a
pp (Exp_Let n e b  )  =  "let"  >|< pp n >|< "=" >|< pp e >|<
                         "in"   >|< pp b

data Doc = ...                      ^^ -- pretty print document
(>|<) :: Doc -> Doc -> Doc          ^^ -- concatenate horizontally
%%]]

  This works well if |pp| does not use info encapsulated in |algoW|
  
\end{frame}


\begin{frame}
  \frametitle{Implementation, pretty printing}
  
  Leads to nanopasses\CITE{Keep:2013:NFC:2520988}\CITE{laemmel03boilerplate}
  in compiler: small, maintainable, isolates solution for single (independent) problem
  
  \begin{itemize}
  \item Used in UHC for (e.g.) transformations of intermediate representations
  \item Can be inefficient, boilerplate overhead
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Implementation, pretty printing}
  
  The reality here is that |pp| and |algoW| are dependent:
  pretty printing uses the inferred type (|te|) and error messages (|eu|) of |algoW|

%%[[wrap=safecode
pp :: Exp -> Doc
pp (Exp_App f a    )  =  pp f >|< pp a (RED( >|< pp eu))
pp (Exp_Let n e b  )  =  "let"  >|< pp n  (RED( >|< ":" >|< pp te >|<))
                                          >|< "=" >|< pp  e >|<
                         "in"   >|< pp b
%%]]

  Aspects type and pretty printing are not independent!

  In general, more complex analyses are dependent.

\end{frame}


\begin{frame}
  \frametitle{Implementation}

  Solution 1: add |pp| to |algoW|:

{\small
%%[[wrap=safecode
algoW :: Env -> (Subst, Int) -> Exp -> (Ty, (Subst, Int), Err(RED(, Doc)))
algoW env st (Exp_App f a) =
    (s4 $-> v, (s4, uniq st3), ef ++ ea ++ eu(RED(, pf >|< pa >|< pp eu)))
  where 
    (tf,  st1, ef(RED(, pf)))  = algoW env st   f    
    (ta,  st2, ea(RED(, pa)))  = algoW env st1  a    
    (su,  eu)                  = unify  (s3 $-> tf) (TyArr ta v)
    ...
%%]]
}

  Refactorization in the 'wrong' direction

  \begin{itemize}
  \item Adding an aspect means a manual overhaul of boilerplate code
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Implementation}

  Solution 2: plumbing via underlying implementation language

\begin{itemize}
\item A monadic interface for Algorithm W
%%[[wrap=safecode
algoW
      ::  (  MonadReader Env m                  ^^ -- scoped name mapping
          ,  MonadState (Subst, Int) m          ^^ -- global state
          ,  MonadError Err m                   ^^ -- error/exception
          (RED(, MonadWriter Doc m))            ^^ -- \Red{pretty printing}
          ) => Exp -> m Ty
%%]]
\item Boilerplate partially done by monad transformer lifting
\item Allows monadic ordering: state left-to-right, by default no mutual recursion, ...
\item Possibly constrained by underlying type system%, may require a monad per aspect
\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Solution 3 (taken by UHC): DSL for computations over ASTs

  \begin{itemize}
  \item Each individual computation expressed as attribute
  \item Specification for each attribute can be separately described, to be combined elsewhere
  \item A compiler (UUAGC) glues separate specifications, generating functional program, including boilerplate
  \end{itemize}

  Data flow over tree fragments, thinking in terms of attributes associated with parent and children in AST
  
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Implementation: AG
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementation: Attribute Grammar}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Way of thinking and programming now can be different
   
  \begin{itemize}
  \item All computation is defined in terms of attributes associated with parent and children
  \item Attributes are defined in terms of other attributes, thus specifying small dataflow fragments for parent and children
  \end{itemize}
  
  \begin{center}
  \agpictureAtY{4}{2}{flops2016-keynote/lam1env}
  \end{center}

  \begin{itemize}
  \item Inherited attributes 'travel' downwards (from root to leaves), synthesized upwards
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Environment
  
  \begin{center}
  \agpictureScaled{0.5}{flops2016-keynote/lam1env}
  \end{center}

%%[[wrap=safecode
DATA Exp                                    ^^ -- AST
  | App     f     : Exp
            a     : Exp

ATTR Exp [ env: Env | | ]                   ^^ -- inherited, from root to leaves

SEM Exp
  | App     f   .   env     =   @lhs.env    ^^ -- copied downwards
            a   .   env     =   @lhs.env
%%]]

Boilerplate copying (for |env|) usually omitted and generated automatically

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Unique number generation
  
  \begin{center}
  \agpictureAtY{8}{4}{flops2016-keynote/lam1uniq}
  \end{center}

%%[[wrap=safecode
ATTR Exp [ | uniq: Int | ]                   ^^ -- synthesized + inherited = state

SEM Exp
  | App     loc     .   v       =   mkTyVar @lhs.uniq
            f       .   uniq    =   @lhs.uniq + 1
%%]]

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Substitution
  
  \begin{center}
  \agpictureAtY{10}{5}{flops2016-keynote/lam1subst}
  \end{center}

%%[[wrap=safecode
ATTR Exp [ | subst: Subst | ]
%%]]

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Substitution, type, unification
  
  \begin{center}
  \agpictureAtY{12}{7}{flops2016-keynote/lam1ty}
  \end{center}

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  \begin{center}
  \agpictureScaledAtY{11}{6}{0.5}{flops2016-keynote/lam1ty}
  \end{center}

%%[[wrap=safecode
ATTR Exp [ | | ty: Ty ]     ^^ -- synthesized

SEM Exp
  | App  (loc.su,loc.eu)   =  unify  (@a.subst $-> @f.ty)
                                     (TyArr @a.ty @v)
         loc  .  s4        =  @su $-> @a.subst
         lhs  .  ty        =  @s4 $-> @v
              .  subst     =  @s4
%%]]

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Error collecting
  
  \begin{center}
  \agpictureAtY{8}{4}{flops2016-keynote/lam1err}
  \end{center}

%%[[wrap=safecode
ATTR Exp [ | | err : Err ]

SEM Exp
  | App				lhs	.	err		=	@eu ++ @f.err ++ @a.err
%%]]

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Similarly: pretty printing
  
  \begin{center}
  \agpictureAtY{7}{3}{flops2016-keynote/lam1pp}
  \end{center}

%%[[wrap=safecode
ATTR Exp [ | | pp : Doc ]

SEM Exp
  | App				lhs	.	pp		=	@f.pp >|< @a.pp >|< ppErr @eu
%%]]

(Ignoring layout details)

\end{frame}


\begin{frame}
  \frametitle{Moments of reflection}
  
  What have we done so far?

  \begin{itemize}
    \item Started with concise declarative specification, which
    \begin{itemize}
      \item Via algorithmic version
      \item Led to Attribute Grammar implementation
      \item Where all aspects can be described independently even though there are dependencies
      \item Generates Haskell using UUAGC (UU AG compiler)
      \item Combines separate specifications, generates boilerplate code
    \end{itemize}
    \item This works very well!
    \begin{itemize}
      \item In UHC, almost all functionality involving trees is expressed using AGs
      \item Integrates with Haskell ecosystem
    \end{itemize}
  \end{itemize}

  \pause
  But...

\end{frame}


\begin{frame}
  \frametitle{Moments of reflection}
  
  Drawbacks

  \begin{itemize}
    \item We still have to know about dependencies
    \begin{itemize}
      \item Luckily, UUAGC gives feedback about dependency related errors
    \end{itemize}
    \item UUAGC is a preprocessor: checks for AG specifics, but not Haskell specifics of embedded Haskell code
    \begin{itemize}
      \item We get Haskell errors too late, only when generated code is compiled
    \end{itemize}
    \item One has to learn a separate language
    \begin{itemize}
      \item And the additional tooling etc.
    \end{itemize}
    \item Implementation done manually, what guarantees do we have about consistency with type rules?
    \begin{itemize}
      \item Maintaining two copies of the same is a nightmare
    \end{itemize}    
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Moments of reflection}

  What can we \Emph{guarantee} in order to allow for easier change?
  
  \begin{itemize}
    \item Embed DSLs, allowing better error reporting
    \item One DSL for both type rules and implementation of them
  \end{itemize}
  
  \pause
  The \Emph{ideal} would be to be able to specify declaratively

  \begin{itemize}
    \item The type system, with 'magic' figuring out a corresponding implementation
    \item An implementation using various DSLs inside one host language
  \end{itemize}
  
  The \Emph{reality} is that type systems soon are too complex,
  'magic' does not exist, embedding DSLs is still ongoing research,
  and an implementation involves usually |>1| host languages
  
  \pause
  \begin{itemize}
    \item Why? How is this mitigated in UHC?
    \item First, we look at consistency between type rules and implementation
  \end{itemize}
  

\end{frame}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Implementation: Ruler
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementation: Ruler}


\begin{frame}
  \frametitle{Implementation: Ruler}
  
  Specification of
  
  \[
  \rulerCmdUse{Lamnochng.A.exp.core.app}
  \]

  Is \latex\ + \lhstex\ a good specification language for type rules?

\end{frame}


\begin{frame}
  \frametitle{Implementation: Ruler}
  
  \latex\ + \lhstex:

{\tiny
%%[[wrap=verbatim
\rulerRule{app}{A}
{ | tvar | \;\mbox{fresh} | |
\\| subst ; env :- f : ty | _{ | f |} | ~> subst | _{ | f |} | |
\\| subst | _{ | a |} | ty | _{ | f |} | === ty | _{ | a |} | -> tvar ~> subst | _{ | u |} | |
\\| subst | _{ | f |} | ; env :- a : ty | _{ | a |} | ~> subst | _{ | a |} | |
 }
{ | subst ; env :- f ^^ a : subst | _{ | u |} | tvar ~> subst | _{ | u |} | subst | _{ | a |} | | }
%%]]
}

Gives us pretty rendering in papers and (these) slides...

But...

  \begin{itemize}
    \item Check for identifier introduction?
    \item Judgement conforms to its required structure?
    \item Typing of type rules?
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Implementation: Ruler}
  
  How can we keep type rules and their implementation consistent?
  
  \[
  \rulerCmdUse{Lamnochng.A.exp.core.app}
  \]

{\small
%%@Lam_A_ruler.2.exp.app wrap=safecode
}

\end{frame}


\begin{frame}
  \frametitle{Implementation: Ruler}
  
  In general, given a specification for some semantics, we (want to)
  
  \begin{enumerate}
    \item \label{semgenrender} Render it for \Emph{human reading} \& reasoning,
    \item \label{semgenreason} Feed it into \Emph{theorem proving} machinery for (automated/mechanized) reasoning,
    \item \label{semgenexec} Generate code for \Emph{actual execution}
  \end{enumerate}
  
  The \Emph{ideal} would be to obtain all 3 from a single description.
  
  The \Emph{reality} is that for a given tool we get (approx) 2 out of 3...
  
  \vspace{2ex} \pause
  For UHC, |Ruler| gives us \ref{semgenrender} \& \ref{semgenexec}:
  previous slide contains generated rendering and AG code

\end{frame}




%}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type system: non syntax driven complexity
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Type system: non syntax driven complexity}


\begin{frame}
  \frametitle{Type system: non syntax driven complexity}

  \begin{itemize}
    \item XX
    \begin{itemize}
      \item XX
    \end{itemize}
    
    \item XX
  \end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Language variants: Shuffle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Language variants: Shuffle}


\begin{frame}
  \frametitle{Language variants: Shuffle}

  \begin{itemize}
    \item XX
    \begin{itemize}
      \item XX
    \end{itemize}
    
    \item XX
  \end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Attribute Grammar: as EDSL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Attribute Grammar: as EDSL}


\begin{frame}
  \frametitle{Attribute Grammar: as EDSL}

  \begin{itemize}
    \item XX
    \begin{itemize}
      \item XX
    \end{itemize}
    
    \item XX
  \end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Attribute Grammar: incrementality
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Attribute Grammar: incrementality}


\begin{frame}
  \frametitle{Attribute Grammar: incrementality}

  \begin{itemize}
    \item XX
    \begin{itemize}
      \item XX
    \end{itemize}
    
    \item XX
  \end{itemize}

\end{frame}


%%]

%%[bibPreamble
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Preamble for bib refs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{biblatex}
\addbibresource{flops2016-keynote.bib}
%%]

%%[XX
\begin{frame}
  \frametitle{XX}

  \begin{itemize}
    \item XX
    \begin{itemize}
      \item XX
    \end{itemize}
    
    \item Complexity
  \end{itemize}

\end{frame}


%%]
