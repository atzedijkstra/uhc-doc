%%[preamble
%\barhs
%\setlength{\coderulewidth}{1.5pt}

\newcommand{\CITE}[1]{\footnote{\citetitle{#1}, \citeyear{#1}}}

\newcommand{\Red}[1]{{\color{red}#1}}
\newcommand{\Itl}[1]{\textit{#1}}
\newcommand{\Emph}[1]{\Red{\Itl{#1}}}

%format (RED(x))	= "\Red{" x "}"

%format tvara	= "\alpha"
%format tvarb	= "\beta"
%format tvar	= tvara
%format ty		= "\tau"
%format tya		= ty "_a"
%format Ty		= ty
%format pty		= "\sigma"
%format PTy		= pty
%format env		= "\Gamma"
%format Env		= env
%format exp		= "e"
%format Exp		= exp
%format subst	= "\theta"
%format Subst	= subst

%format oplus	= "\oplus"
%format otimes	= "\otimes"

%format TyInt	= "Int"
%%]

%%[intro
\begin{frame}
  \frametitle{\Emph{UHC}: Coping with Compiler \Emph{Complexity}}
  
  \begin{itemize}
    \item \Emph{UHC}: Utrecht Haskell Compiler
    \begin{itemize}
      \item Haskell2010 implementation
      \item Primarily intended for play \& experimentation: higher ranked types, partial type signatures, generic deriving, local instances, java(script) backend, ...
      \item Inspiration for tooling
    \end{itemize}
    
    \item \Emph{Complexity}: Dimensions of complexity
    \begin{itemize}
      \item From specification to implementation
      \item From few to many (combined) language features
    \end{itemize}
    
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{From specification to implementation}
  Outline

  \begin{itemize}
    \item Type system
    \item Impl adds computational direction: from rel to fun
    \item Specify as function
    \item Specify as AG
    \item Specify as Ruler, DSL, as beefed up AG
    \item Embed AG (Viera)
    \item Issue: repr subst
    \item Issue: free vars, leading to
    \item Optimize via incrementality (Bransen)
    \item Reasoning, CHR as DSL
  \end{itemize}
  
  Theme: use DSLs to cope with complexity

\end{frame}


\begin{frame}
  \frametitle{From few to many (combined) language features}
  UHC language feature ordering

  \begin{itemize}
    \item HM
    \item Higher ranked
    \item Type classes (local instances)
    \item Code gen
    \item ...
    \item Module system
    \item Libraries
    \item Haskell (report) corner cases
    \item Haskell2010
  \end{itemize}
  
  Theme: distinguish aspects/features

\end{frame}


\begin{frame}
  \frametitle{Today's plan}
  
  \begin{itemize}
  \item Write a smallish UHC
  \item Observe what is or will be problematic
  \item Solutions tried for UHC \& lessons learned
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Demo language}

\begin{itemize}
\item Basic functional language
%%[[wrap=safecode
   exp     ::=     i                       ^^ -- base: int
           |       n                       ^^ -- name reference
           |       exp ^^ exp              ^^ -- application
           |       \n.exp                  ^^ -- abstraction
           |       let n = exp in exp      ^^ -- let binding
%%]]

\item With a Hindley-Milner type system
%%[[wrap=safecode
   ty      ::=     Int | ty -> ty | tvar
   pty     ::=     ty | forall tvar . pty
%%]]
\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Demo language}

\begin{itemize}
\item Language example
%%[[wrap=safecode
let id = \x.x in
let id2 = id id id id in
id id2 (id 5)
%%]]

\item Desired output and results
  \begin{itemize}
  \item Some analysis for some semantics: type
  \item Some error reporting: name errors, type errors
  \item Some code generation using analysis results: pretty printing
  \end{itemize}

\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Demo language}

\begin{itemize}
\item Compiler output

%%[[wrap=verbatimsmall
-- PP
let id : forall a. a -> (a)
       = \x.x in
let id2 : forall a. a -> (a)
        = id (id) (id) (id) in
id (id2) (id (5))
-- Ty
Int
%%]]
\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Demo language}

\begin{itemize}
\item Language example with a name error
%%[[wrap=safecode
let id = \x.y in
f 4
%%]]

\item Compiler output

%%[[wrap=verbatimsmall
-- PP
let id : forall a. a -> (ERR)
       = \x.y{- Not introduced: y -} in
f{- Not introduced: f -} (4)
-- Errors
Not introduced: y
Not introduced: f
%%]]
\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Demo language}

\begin{itemize}
\item Language example with typing error (Y fixpoint combinator)
%%[[wrap=safecode
\w . (\x.w(x x)) (\x.w(x x))
%%]]

\item Compiler output

%%[[wrap=verbatimsmall
-- PP
\w.\x.w (x (x){- Occurs: v2
                         v2 -> (v5) -}
        ) (\x.w (x (x){- Occurs: v8
                                 v8 -> (v11) -}
                )
          )
-- Errors
Occurs: v2
        v2 -> (v5)
Occurs: v8
        v8 -> (v11)
%%]]
\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Writing a compiler for the demo language}
  
  What needs to be done?
  \begin{itemize}
  \item Specify the semantics (here: only type, not operational)
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Type semantics, declarative}

  Hindley-Milner type system (HM), declarative specification for type system
  {\small
  \rulerCmdUse{Lam.D.exp.onslide}
  }
  
  + generalization, instantiation ...

\end{frame}


\begin{frame}
  \frametitle{Type semantics, declarative}

  Generalization, instantiation
  {\small
  \rulerCmdUse{Lam.D.exp.gen}
  }
  
  \pause
  Can we directly implement this?
  \begin{itemize}
  \item When to apply rules?
  \item How to solve equations implied implicitly by multiple occurrences of meta variables (like |tya|)?
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Type semantics, syntax directed}

  For HM this is well known\footnote{\url{https://en.wikipedia.org/wiki/Hindley-Milner_type_system}}
  {\small
  \rulerCmdUse{Lam.SD.exp.onslide.sd}
  }
  
  Add and allow for computational direction
  \begin{itemize}
  \item When to apply rules? Make it syntax directed
  \item How to solve equations? Algorithm W (for example), unification, type variables \& substitution
  \end{itemize}
  
  But...
  \pause
  for an implementation more and more design, algorithmic, and engineering decisions have to be made
  
  %Observation: 
  

\end{frame}


\begin{frame}
  \frametitle{Type semantics, algorithmic}
  
  Algorithm W

  {\small
  \rulerCmdUse{Lam.A.exp.onslide}
  }

  Ready to implement...
  
\end{frame}

%{

%format Ty_		= ty
%format Env_	= env
%format Exp_	= exp
%format Subst_	= subst
%format subst_	= subst

%format Ty		= "Ty"
%format Env		= "Env"
%format env		= "env"
%format Exp		= "Exp"
%format Subst	= "Subst"
%format subst	= "subst"

%format TyInt	= "TyInt"

%format $->		= $ "_{\theta}"

\begin{frame}
  \frametitle{Implementation}

Haskell implementation of Algorithm W

%%[[wrap=safecode
algoW :: Env -> (Subst, Int) -> Exp -> (Ty, (Subst, Int), Err)
%%]]

\begin{itemize}
\item |Env, Env_|: scoped environment, mapping from identifiers to types
\item |Exp, Exp_|: term AST
\item |Ty, Ty_|: types
\item |Int|: unique number generation, for fresh type variables
\item |Subst, Subst_|: substitution, mapping from type variables to types
\item |Err|: errors
\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Implementation, purely functional}

{\small
%%[[wrap=safecode
algoW :: Env -> (Subst, Int) -> Exp -> (Ty, (Subst, Int), Err)
algoW env st (Exp_App f a) =
    (s4 $-> v, (s4, uniq st3), ef ++ ea ++ eu)
  where 
    (tf,  st1, ef)  = algoW env st   f                  ^^ -- recurse for function
    (ta,  st2, ea)  = algoW env st1  a                  ^^ -- recurse for argument
    (v,   st3)      = fresh  st2                        ^^ -- new fresh type var
    s3              = subst  st3                        ^^ -- get current subst
    (su,  eu)       = unify  (s3 $-> tf)                ^^ -- apply subst, unify
                             (TyArr ta v)
    s4              = su $-> s3
%%]]
}

\end{frame}


\begin{frame}
  \frametitle{Implementation, purely functional}

Utility types (for reference)
{\small
%%[[wrap=safecode
data TyVar  = TV Int ...
data Ty     = TyInt | TyVar TyVar | TyArr Ty Ty | ...
data Exp    = Exp_App  Exp Exp | ...
type Env    = [(String,Ty)]
type Subst  = [(TyVar,Ty)]
class Substitutable x where {($->) :: Subst -> x -> x}
%%]]
}

\end{frame}


\begin{frame}
  \frametitle{Moments of reflection}
  
  What have we done so far?

  \begin{itemize}
    \item Started with concise declarative specification, which
    \begin{itemize}
      \item Via algorithmic version
      \item Led to functional implementation
    \end{itemize}
    \item But...
    \begin{itemize}
      \item Many low level details crept in while still many details are left out
      \item An actual implementation must do more than just specify semantics: parser, scanner, ...
      \item Approx 300 LOC (without comment)
    \end{itemize}
    
    \item And...
    \begin{itemize}
      \item We are not done yet...
      \item Pretty printing
      % \item Error gathering
    \end{itemize}
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Moments of reflection}

  Can we \Emph{scale up}?
  
  \begin{itemize}
    \item The things/aspects we want to specify/compute per language construct?
    \item The number of language constructs?
  \end{itemize}
  
  \pause
  The \Emph{ideal} would be to be able to specify independently

  \begin{itemize}
    \item Aspects |a1| and |a2| and then combine them with some operator |oplus| into |a1 oplus a2|
    \item Language features |f1| and |f2| and then combine them with some operator |otimes| into |f1 otimes f2|
  \end{itemize}
  
  The \Emph{reality} is that aspects, features, and their combination usually must be 'aware' of each other to some degree.
  
  \pause
  \begin{itemize}
    \item Why?
    \item How is this mitigated in UHC?
  \end{itemize}
  

\end{frame}


\begin{frame}
  \frametitle{Implementation, pretty printing}
  
  The ideal would be to define pretty printing independently of algoW:

%%[[wrap=safecode
pp :: Exp -> Doc
pp (Exp_App f a    )  =  pp f >|< pp a
pp (Exp_Let n e b  )  =  "let"  >|< pp n >|< "=" >|< pp e >|<
                         "in"   >|< pp b

data Doc = ...                      ^^ -- pretty print document
(>|<) :: Doc -> Doc -> Doc          ^^ -- concatenate horizontally
%%]]

  This works well if |pp| does not use info encapsulated in |algoW|
  
\end{frame}


\begin{frame}
  \frametitle{Implementation, pretty printing}
  
  Leads to nanopasses\CITE{Keep:2013:NFC:2520988}\CITE{laemmel03boilerplate}
  in compiler: small, maintainable, isolates solution for single (independent) problem
  
  \begin{itemize}
  \item Used in UHC for (e.g.) transformations of intermediate representations
  \item Can be inefficient, boilerplate overhead
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Implementation, pretty printing}
  
  The reality here is that |pp| and |algoW| are dependent:
  pretty printing uses the inferred type (|te|) and error messages (|eu|) of |algoW|

%%[[wrap=safecode
pp :: Exp -> Doc
pp (Exp_App f a    )  =  pp f >|< pp a (RED( >|< pp eu))
pp (Exp_Let n e b  )  =  "let"  >|< pp n  (RED( >|< ":" >|< pp te >|<))
                                          >|< "=" >|< pp  e >|<
                         "in"   >|< pp b
%%]]

  Aspects type and pretty printing are not independent!

  In general, more complex analyses are dependent.

\end{frame}


\begin{frame}
  \frametitle{Implementation}

  Solution 1: add |pp| to |algoW|:

{\small
%%[[wrap=safecode
algoW :: Env -> (Subst, Int) -> Exp -> (Ty, (Subst, Int), Err(RED(, Doc)))
algoW env st (Exp_App f a) =
    (s4 $-> v, (s4, uniq st3), ef ++ ea ++ eu(RED(, pf >|< pa >|< pp eu)))
  where 
    (tf,  st1, ef(RED(, pf)))  = algoW env st   f    
    (ta,  st2, ea(RED(, pa)))  = algoW env st1  a    
    (su,  eu)                  = unify  (s3 $-> tf) (TyArr ta v)
    ...
%%]]
}

  Refactorization in the 'wrong' direction

  \begin{itemize}
  \item Adding an aspect means a manual overhaul of boilerplate code
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Implementation}

  Solution 2: plumbing via underlying implementation language

\begin{itemize}
\item A monadic interface for Algorithm W
%%[[wrap=safecode
algoW
      ::  (  MonadReader Env m                  ^^ -- scoped name mapping
          ,  MonadState (Subst, Int) m          ^^ -- global state
          ,  MonadError Err m                   ^^ -- error/exception
          (RED(, MonadWriter Doc m))            ^^ -- \Red{pretty printing}
          ) => Exp -> m Ty
%%]]
\item Boilerplate partially done by monad transformer lifting
\item Allows monadic ordering: state left-to-right, by default no mutual recursion, ...
\item Possibly constrained by underlying type system%, may require a monad per aspect
\end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Solution 3 (taken by UHC): DSL for computations over ASTs

  \begin{itemize}
  \item Each individual computation expressed as attribute
  \item Specification for each attribute can be separately described, to be combined elsewhere
  \item A compiler (UUAGC) glues separate specifications, generating functional program, including boilerplate
  \end{itemize}

  Data flow over tree fragments, thinking in terms of attributes associated with parent and children in AST
  
\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Way of thinking and programming now can be different
   
  \begin{itemize}
  \item All computation is defined in terms of attributes associated with parent and children
  \item Attributes are defined in terms of other attributes, thus specifying small dataflow fragments for parent and children
  \end{itemize}
  
  \begin{center}
  \agpictureAtY{4}{2}{flops2016-keynote/lam1env}
  \end{center}

  \begin{itemize}
  \item Inherited attributes 'travel' downwards (from root to leaves), synthesized upwards
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Environment
  
  \begin{center}
  \agpictureScaled{0.5}{flops2016-keynote/lam1env}
  \end{center}

%%[[wrap=safecode
DATA Exp                                    ^^ -- AST
  | App     f     : Exp
            a     : Exp

ATTR Exp [ env: Env | | ]                   ^^ -- inherited, from root to leaves

SEM Exp
  | App     f   .   env     =   @lhs.env    ^^ -- copied downwards
            a   .   env     =   @lhs.env
%%]]

Boilerplate copying (for |env|) can be omitted and generated automatically

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Unique number generation
  
  \begin{center}
  \agpictureAtY{8}{4}{flops2016-keynote/lam1uniq}
  \end{center}

%%[[wrap=safecode
ATTR Exp [ | uniq: Int | ]                   ^^ -- synthesized + inherited = state

SEM Exp
  | App     loc     .   v       =   mkTyVar @lhs.uniq
            f       .   uniq    =   @lhs.uniq + 1
%%]]

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Substitution
  
  \begin{center}
  \agpictureAtY{10}{5}{flops2016-keynote/lam1subst}
  \end{center}

%%[[wrap=safecode
ATTR Exp [ | subst: Subst | ]
%%]]

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Substitution, type, unification
  
  \begin{center}
  \agpictureAtY{11}{6}{flops2016-keynote/lam1ty}
  \end{center}

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  \begin{center}
  \agpictureScaledAtY{11}{6}{0.5}{flops2016-keynote/lam1ty}
  \end{center}

%%[[wrap=safecode
ATTR Exp [ | | ty: Ty ]     ^^ -- synthesized

SEM Exp
  | App  (loc.su,loc.eu)   =  unify  (@a.subst $-> @f.ty)
                                     (TyArr @a.ty @v)
         loc  .  s4        =  @su $-> @a.subst
         lhs  .  ty        =  @s4 $-> @v
              .  subst     =  @s4
%%]]

\end{frame}


\begin{frame}
  \frametitle{Attribute grammars}
  
  Error collecting
  
  \begin{center}
  \agpictureAtY{8}{4}{flops2016-keynote/lam1err}
  \end{center}

%%[[wrap=safecode
ATTR Exp [ | | err : Err ]

SEM Exp
  | App				lhs	.	err		=	@eu ++ @f.err ++ @a.err
%%]]

\end{frame}


\begin{frame}
  \frametitle{Implementation}

And (finally) some implementation code...

%%[[wrap=safecode
algoW (Exp_App f a) = do
  tf <- algoW f                 ^^ -- recurse for function
  ta <- algoW a                 ^^ -- recurse for argument
  s <- subst                    ^^ -- get current subst
  v <- fresh                    ^^ -- new fresh type var
  unif (s $-> tf) (TyArr ta v)  ^^ -- apply subst, unify
  s <- subst
  return $ s $-> v              ^^ -- apply subst, return
%%]]

\end{frame}


%}


%%]

%%[bibPreamble
\usepackage{biblatex}
\addbibresource{flops2016-keynote.bib}
%%]

%%[XX
\begin{frame}
  \frametitle{XX}

  \begin{itemize}
    \item XX
    \begin{itemize}
      \item XX
    \end{itemize}
    
    \item Complexity
  \end{itemize}

\end{frame}


%%]
